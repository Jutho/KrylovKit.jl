<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · KrylovKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">KrylovKit.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Package-features-and-alternatives"><span>Package features and alternatives</span></a></li><li><a class="tocitem" href="#Current-functionality"><span>Current functionality</span></a></li><li><a class="tocitem" href="#Future-functionality?"><span>Future functionality?</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/intro/">Introduction</a></li><li><a class="tocitem" href="man/linear/">Linear problems</a></li><li><a class="tocitem" href="man/eig/">Eigenvalue problems</a></li><li><a class="tocitem" href="man/svd/">Singular value problems</a></li><li><a class="tocitem" href="man/matfun/">Functions of matrices and linear maps</a></li><li><a class="tocitem" href="man/algorithms/">Available algorithms</a></li><li><a class="tocitem" href="man/implementation/">Details of the implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="KrylovKit.jl"><a class="docs-heading-anchor" href="#KrylovKit.jl">KrylovKit.jl</a><a id="KrylovKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKit.jl" title="Permalink"></a></h1><p>A Julia package collecting a number of Krylov-based algorithms for linear problems, singular value and eigenvalue problems and the application of functions of linear maps or operators to vectors.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>KrylovKit.jl accepts general functions or callable objects as linear maps, and general Julia objects with vector like behavior (see below) as vectors.</p><p>The high level interface of KrylovKit is provided by the following functions:</p><ul><li><a href="man/linear/#KrylovKit.linsolve"><code>linsolve</code></a>: solve linear systems <code>A*x = b</code></li><li><a href="man/eig/#KrylovKit.eigsolve"><code>eigsolve</code></a>: find a few eigenvalues and corresponding eigenvectors of an   eigenvalue problem <code>A*x = λ x</code></li><li><a href="man/eig/#KrylovKit.geneigsolve"><code>geneigsolve</code></a>: find a few eigenvalues and corresponding vectors of a   generalized eigenvalue problem <code>A*x = λ*B*x</code></li><li><a href="man/svd/#KrylovKit.svdsolve"><code>svdsolve</code></a>: find a few singular values and corresponding left and right   singular vectors <code>A*x = σ * y</code> and <code>A&#39;*y = σ*x</code>.</li><li><a href="man/matfun/#KrylovKit.exponentiate"><code>exponentiate</code></a>: apply the exponential of a linear map to a vector</li><li><a href="man/matfun/#KrylovKit.expintegrator"><code>expintegrator</code></a>: exponential integrator for a linear non-homogeneous ODE,   generalization of <code>exponentiate</code></li></ul><h2 id="Package-features-and-alternatives"><a class="docs-heading-anchor" href="#Package-features-and-alternatives">Package features and alternatives</a><a id="Package-features-and-alternatives-1"></a><a class="docs-heading-anchor-permalink" href="#Package-features-and-alternatives" title="Permalink"></a></h2><p>This section could also be titled &quot;Why did I create KrylovKit.jl&quot;?</p><p>There are already a fair number of packages with Krylov-based or other iterative methods, such as</p><ul><li><a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a>: part of the   <a href="https://github.com/JuliaMath">JuliaMath</a> organisation, solves linear systems and least   square problems, eigenvalue and singular value problems</li><li><a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a>: part of the   <a href="https://github.com/JuliaSmoothOptimizers">JuliaSmoothOptimizers</a> organisation, solves   linear systems and least square problems, specific for linear operators from   <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl">LinearOperators.jl</a>.</li><li><a href="https://github.com/lruthotto/KrylovMethods.jl">KrylovMethods.jl</a>: specific for sparse   matrices</li><li><a href="https://github.com/acroy/Expokit.jl">Expokit.jl</a>: application of the matrix   exponential to a vector</li><li><a href="https://github.com/haampie/ArnoldiMethod.jl">ArnoldiMethod.jl</a>: Implicitly restarted   Arnoldi method for eigenvalues of a general matrix</li><li><a href="https://github.com/haampie/JacobiDavidson.jl">JacobiDavidson.jl</a>: Jacobi-Davidson   method for eigenvalues of a general matrix</li><li><a href="https://github.com/JuliaDiffEq/ExponentialUtilities.jl">ExponentialUtilities.jl</a>: Krylov   subspace methods for matrix exponentials and <code>phiv</code> exponential integrator products. It   has specialized methods for subspace caching, time stepping, and error testing which are   essential for use in high order exponential integrators.</li><li><a href="https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>:   contains implementations of <a href="https://docs.juliadiffeq.org/latest/solvers/split_ode_solve/#OrdinaryDiffEq.jl-2">high order exponential integrators</a>   with adaptive Krylov-subspace calculations for solving semilinear and nonlinear ODEs.</li></ul><p>These packages have certainly inspired and influenced the development of KrylovKit.jl. However, KrylovKit.jl distinguishes itself from the previous packages in the following ways:</p><ol><li><p>KrylovKit accepts general functions to represent the linear map or operator that defines  the problem, without having to wrap them in a  <a href="https://github.com/Jutho/LinearMaps.jl"><code>LinearMap</code></a> or  <a href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl"><code>LinearOperator</code></a> type.  Of course, subtypes of <code>AbstractMatrix</code> are also supported. If the linear map (always  the first argument) is a subtype of <code>AbstractMatrix</code>, matrix vector multiplication is  used, otherwise it is applied as a function call.</p></li><li><p>KrylovKit does not assume that the vectors involved in the problem are actual subtypes  of <code>AbstractVector</code>. Any Julia object that behaves as a vector is supported, so in  particular higher-dimensional arrays or any custom user type that supports the  following functions (with <code>v</code> and <code>w</code> two instances of this type and <code>α, β</code> scalars  (i.e. <code>Number</code>)):</p><ul><li><code>Base.:*(α, v)</code>: multiply <code>v</code> with a scalar <code>α</code>, which can be of a different scalar   type; in particular this method is used to create vectors similar to <code>v</code> but with a   different type of underlying scalars.</li><li><code>Base.similar(v)</code>: a way to construct vectors which are exactly similar to <code>v</code></li><li><code>LinearAlgebra.mul!(w, v, α)</code>: out of place scalar multiplication; multiply   vector <code>v</code> with scalar <code>α</code> and store the result in <code>w</code></li><li><code>LinearAlgebra.rmul!(v, α)</code>: in-place scalar multiplication of <code>v</code> with <code>α</code>; in   particular with <code>α = false</code>, <code>v</code> is the corresponding zero vector</li><li><code>LinearAlgebra.axpy!(α, v, w)</code>: store in <code>w</code> the result of <code>α*v + w</code></li><li><code>LinearAlgebra.axpby!(α, v, β, w)</code>: store in <code>w</code> the result of <code>α*v + β*w</code></li><li><code>LinearAlgebra.dot(v,w)</code>: compute the inner product of two vectors</li><li><code>LinearAlgebra.norm(v)</code>: compute the 2-norm of a vector</li></ul><p>Algorithms in KrylovKit.jl are tested against such a minimal implementation (named  <code>MinimalVec</code>) in the test suite. This type is only defined in the tests. However,  KrylovKit provides two types implementing this interface and slightly more, to make  them behave more like <code>AbstractArrays</code> (e.g. also <code>Base.:+</code> etc), which can facilitate  certain applications:</p><ul><li><a href="@ref"><code>RecursiveVec</code></a> can be used for grouping a set of vectors into a single   vector like structure (can be used recursively). This is more robust than trying to   use nested <code>Vector{&lt;:Vector}</code> types.</li><li><a href="@ref"><code>InnerProductVec</code></a> can be used to redefine the inner product (i.e. <code>dot</code>)   and corresponding norm (<code>norm</code>) of an already existing vector like object. The   latter should help with implementing certain type of preconditioners.</li></ul></li></ol><h2 id="Current-functionality"><a class="docs-heading-anchor" href="#Current-functionality">Current functionality</a><a id="Current-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Current-functionality" title="Permalink"></a></h2><p>The following algorithms are currently implemented</p><ul><li><code>linsolve</code>: <a href="man/algorithms/#KrylovKit.CG"><code>CG</code></a>, <a href="man/algorithms/#KrylovKit.GMRES"><code>GMRES</code></a></li><li><code>eigsolve</code>: a Krylov-Schur algorithm (i.e. with tick restarts) for extremal eigenvalues   of normal (i.e. not generalized) eigenvalue problems, corresponding to   <a href="man/algorithms/#KrylovKit.Lanczos"><code>Lanczos</code></a> for real symmetric or complex hermitian linear maps, and to   <a href="man/algorithms/#KrylovKit.Arnoldi"><code>Arnoldi</code></a> for general linear maps.</li><li><code>geneigsolve</code>: an customized implementation of the inverse-free algorithm of Golub and   Ye for symmetric / hermitian generalized eigenvalue problems with positive definite   matrix <code>B</code> in the right hand side of the generalized eigenvalue problem <span>$A v = B v λ$</span>.   The Matlab implementation was described by Money and Ye and is known as <code>EIGIFP</code>; in   particular it extends the Krylov subspace with a vector corresponding to the step   between the current and previous estimate, analogous to the locally optimal   preconditioned conjugate gradient method (LOPCG). In particular, with Krylov dimension   2, it becomes equivalent to the latter.</li><li><code>svdsolve</code>: finding largest singular values based on Golub-Kahan-Lanczos   bidiagonalization (see <a href="man/algorithms/#KrylovKit.GKL"><code>GKL</code></a>)</li><li><code>exponentiate</code>: a <a href="man/algorithms/#KrylovKit.Lanczos"><code>Lanczos</code></a> based algorithm for the action of the exponential of   a real symmetric or complex hermitian linear map.</li><li><code>expintegrator</code>: exponential integrator for a linear non-homogeneous ODE, computes a   linear combination of the so-called <code>ϕⱼ</code> functions which generalize <code>ϕ₀(z) = exp(z)</code>.</li></ul><h2 id="Future-functionality?"><a class="docs-heading-anchor" href="#Future-functionality?">Future functionality?</a><a id="Future-functionality?-1"></a><a class="docs-heading-anchor-permalink" href="#Future-functionality?" title="Permalink"></a></h2><p>Here follows a wish list / to-do list for the future. Any help is welcomed and appreciated.</p><ul><li>More algorithms, including biorthogonal methods:<ul><li>for <code>linsolve</code>: MINRES, BiCG, BiCGStab(l), IDR(s), ...</li><li>for <code>eigsolve</code>: BiLanczos, Jacobi-Davidson JDQR/JDQZ, subspace iteration (?), ...</li><li>for <code>geneigsolve</code>: trace minimization, block versions</li></ul></li><li>Support both in-place / mutating and out-of-place functions as linear maps</li><li>Least square problems</li><li>Nonlinear eigenvalue problems</li><li>Preconditioners</li><li>Refined Ritz vectors, Harmonic Ritz values and vectors</li><li>Reuse memory for storing vectors when restarting algorithms</li><li>Block versions of the algorithms</li><li>More relevant matrix functions</li></ul><p>Partially done:</p><ul><li>Improved efficiency for the specific case where <code>x</code> is <code>Vector</code> (i.e. BLAS level 2   operations): any vector <code>v::AbstractArray</code> which has <code>IndexStyle(v) == IndexLinear()</code>   now benefits from a multithreaded (use <code>export JULIA_NUM_THREADS = x</code> with <code>x</code> the   number of threads you want to use) implementation that resembles BLAS level 2 style for   the vector operations, provided <code>ClassicalGramSchmidt()</code>, <code>ClassicalGramSchmidt2()</code> or   <code>ClassicalGramSchmidtIR()</code> is chosen as orthogonalization routine.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/intro/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 January 2022 16:51">Tuesday 18 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
