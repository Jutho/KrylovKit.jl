<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation details · KrylovKit.jl</title><meta name="title" content="Implementation details · KrylovKit.jl"/><meta property="og:title" content="Implementation details · KrylovKit.jl"/><meta property="twitter:title" content="Implementation details · KrylovKit.jl"/><meta name="description" content="Documentation for KrylovKit.jl."/><meta property="og:description" content="Documentation for KrylovKit.jl."/><meta property="twitter:description" content="Documentation for KrylovKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">KrylovKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../linear/">Linear problems</a></li><li><a class="tocitem" href="../leastsquares/">Least squares problems</a></li><li><a class="tocitem" href="../eig/">Eigenvalue problems</a></li><li><a class="tocitem" href="../svd/">Singular value problems</a></li><li><a class="tocitem" href="../matfun/">Functions of matrices and linear operators</a></li><li><a class="tocitem" href="../reallinear/">Real linear maps</a></li><li><a class="tocitem" href="../algorithms/">Available algorithms</a></li><li class="is-active"><a class="tocitem" href>Implementation details</a><ul class="internal"><li><a class="tocitem" href="#Orthogonalization"><span>Orthogonalization</span></a></li><li><a class="tocitem" href="#Dense-linear-algebra"><span>Dense linear algebra</span></a></li><li><a class="tocitem" href="#Factorization-types"><span>Factorization types</span></a></li><li><a class="tocitem" href="#Factorization-iterators"><span>Factorization iterators</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Implementation details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation details</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/implementation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h1><h2 id="Orthogonalization"><a class="docs-heading-anchor" href="#Orthogonalization">Orthogonalization</a><a id="Orthogonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonalization" title="Permalink"></a></h2><p>To denote a basis of vectors, e.g. to represent a given Krylov subspace, there is an abstract type <code>Basis{T}</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.Basis" href="#KrylovKit.Basis"><code>KrylovKit.Basis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Basis{T} end</code></pre><p>An abstract type to collect specific types for representing a basis of vectors of type <code>T</code>.</p><p>Implementations of <code>Basis{T}</code> behave in many ways like <code>Vector{T}</code> and should have a <code>length</code>, can be indexed (<code>getindex</code> and <code>setindex!</code>), iterated over (<code>iterate</code>), and support resizing (<code>resize!</code>, <code>pop!</code>, <code>push!</code>, <code>empty!</code>, <code>sizehint!</code>).</p><p>The type <code>T</code> denotes the type of the elements stored in an <code>Basis{T}</code> and can be any custom type that has vector like behavior (as defined in the docs of KrylovKit).</p><p>See <a href="#KrylovKit.OrthonormalBasis"><code>OrthonormalBasis</code></a> for a specific implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/KrylovKit.jl#L107-L120">source</a></section></article><p>Many Krylov based algorithms use an orthogonal basis to parameterize the Krylov subspace. In that case, the specific implementation <code>OrthonormalBasis{T}</code> can be used:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.OrthonormalBasis" href="#KrylovKit.OrthonormalBasis"><code>KrylovKit.OrthonormalBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrthonormalBasis{T} &lt;: Basis{T}</code></pre><p>A list of vector like objects of type <code>T</code> that are mutually orthogonal and normalized to one, representing an orthonormal basis for some subspace (typically a Krylov subspace). See also <a href="#KrylovKit.Basis"><code>Basis</code></a></p><p>Orthonormality of the vectors contained in an instance <code>b</code> of <code>OrthonormalBasis</code> (i.e. <code>all(inner(b[i],b[j]) == I[i,j] for i=1:length(b), j=1:length(b))</code>) is not checked when elements are added; it is up to the algorithm that constructs <code>b</code> to guarantee orthonormality.</p><p>One can easily orthogonalize or orthonormalize a given vector <code>v</code> with respect to a <code>b::OrthonormalBasis</code> using the functions <a href="#KrylovKit.orthogonalize"><code>w, = orthogonalize(v,b,...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>w, = orthonormalize(v,b,...)</code></a>. The resulting vector <code>w</code> of the latter can then be added to <code>b</code> using <code>push!(b, w)</code>. Note that in place versions <a href="#KrylovKit.orthogonalize"><code>orthogonalize!!(v, b, ...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>orthonormalize!!(v, b, ...)</code></a> are also available.</p><p>Finally, a linear combination of the vectors in <code>b::OrthonormalBasis</code> can be obtained by multiplying <code>b</code> with a <code>Vector{&lt;:Number}</code> using <code>*</code> or <code>mul!</code> (if the output vector is already allocated).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L2-L25">source</a></section></article><p>We can orthogonalize or orthonormalize a given vector to another vector (assumed normalized) or to a given <a href="#KrylovKit.OrthonormalBasis"><code>KrylovKit.OrthonormalBasis</code></a> using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.orthogonalize" href="#KrylovKit.orthogonalize"><code>KrylovKit.orthogonalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orthogonalize(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, x
orthogonalize!!(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, x

orthogonalize(v, q, algorithm::Orthogonalizer]) -&gt; w, s
orthogonalize!!(v, q, algorithm::Orthogonalizer]) -&gt; w, s</code></pre><p>Orthogonalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>alg</code> of type <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a>, and return the resulting vector <code>w</code> and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthogonalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthogonal vector <code>w</code> and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>Note that <code>w</code> is not normalized, see also <a href="#KrylovKit.orthonormalize"><code>orthonormalize</code></a>.</p><p>For more information on possible orthogonalization algorithms, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> and its concrete subtypes <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L511-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.orthonormalize" href="#KrylovKit.orthonormalize"><code>KrylovKit.orthonormalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orthonormalize(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, β, x
orthonormalize!!(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, β, x

orthonormalize(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s
orthonormalize!!(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s</code></pre><p>Orthonormalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>alg</code> of type <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a>, and return the resulting vector <code>w</code> (of norm 1), its norm <code>β</code> after orthogonalizing and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>, such that <code>v = β * w + b * x</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthonormalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthonormal vector <code>w</code>, its norm <code>β</code> before normalizing and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>See <a href="#KrylovKit.orthogonalize"><code>orthogonalize</code></a> if <code>w</code> does not need to be normalized.</p><p>For more information on possible orthogonalization algorithms, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> and its concrete subtypes <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L549-L575">source</a></section></article><p>or using the possibly in-place versions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.orthogonalize!!" href="#KrylovKit.orthogonalize!!"><code>KrylovKit.orthogonalize!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orthogonalize(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, x
orthogonalize!!(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, x

orthogonalize(v, q, algorithm::Orthogonalizer]) -&gt; w, s
orthogonalize!!(v, q, algorithm::Orthogonalizer]) -&gt; w, s</code></pre><p>Orthogonalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>alg</code> of type <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a>, and return the resulting vector <code>w</code> and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthogonalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthogonal vector <code>w</code> and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>Note that <code>w</code> is not normalized, see also <a href="#KrylovKit.orthonormalize"><code>orthonormalize</code></a>.</p><p>For more information on possible orthogonalization algorithms, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> and its concrete subtypes <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L511-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.orthonormalize!!" href="#KrylovKit.orthonormalize!!"><code>KrylovKit.orthonormalize!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orthonormalize(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, β, x
orthonormalize!!(v, b::OrthonormalBasis, [x::AbstractVector,] alg::Orthogonalizer]) -&gt; w, β, x

orthonormalize(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s
orthonormalize!!(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s</code></pre><p>Orthonormalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>alg</code> of type <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a>, and return the resulting vector <code>w</code> (of norm 1), its norm <code>β</code> after orthogonalizing and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>, such that <code>v = β * w + b * x</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthonormalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthonormal vector <code>w</code>, its norm <code>β</code> before normalizing and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>See <a href="#KrylovKit.orthogonalize"><code>orthogonalize</code></a> if <code>w</code> does not need to be normalized.</p><p>For more information on possible orthogonalization algorithms, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> and its concrete subtypes <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L549-L575">source</a></section></article><p>The expansion coefficients of a general vector in terms of a given orthonormal basis can be obtained as</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.project!!" href="#KrylovKit.project!!"><code>KrylovKit.project!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project!!(y::AbstractVector, b::OrthonormalBasis, x,
    [α::Number = 1, β::Number = 0, r = Base.OneTo(length(b))])</code></pre><p>For a given orthonormal basis <code>b</code>, compute the expansion coefficients <code>y</code> resulting from projecting the vector <code>x</code> onto the subspace spanned by <code>b</code>; more specifically this computes</p><pre><code class="nohighlight hljs">    y[j] = β*y[j] + α * inner(b[r[j]], x)</code></pre><p>for all <span>$j ∈ r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L75-L87">source</a></section></article><p>whereas the inverse calculation is obtained as</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.unproject!!" href="#KrylovKit.unproject!!"><code>KrylovKit.unproject!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unproject!!(y, b::OrthonormalBasis, x::AbstractVector,
    [α::Number = 1, β::Number = 0, r = Base.OneTo(length(b))])</code></pre><p>For a given orthonormal basis <code>b</code>, reconstruct the vector-like object <code>y</code> that is defined by expansion coefficients with respect to the basis vectors in <code>b</code> in <code>x</code>; more specifically this computes</p><pre><code class="nohighlight hljs">    y = β*y + α * sum(b[r[i]]*x[i] for i = 1:length(r))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L122-L133">source</a></section></article><p>An orthonormal basis can be transformed using a rank-1 update using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.rank1update!" href="#KrylovKit.rank1update!"><code>KrylovKit.rank1update!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank1update!(b::OrthonormalBasis, y, x::AbstractVector,
    [α::Number = 1, β::Number = 1, r = Base.OneTo(length(b))])</code></pre><p>Perform a rank 1 update of a basis <code>b</code>, i.e. update the basis vectors as</p><pre><code class="nohighlight hljs">    b[r[i]] = β*b[r[i]] + α * y * conj(x[i])</code></pre><p>It is the user&#39;s responsibility to make sure that the result is still an orthonormal basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L207-L218">source</a></section></article><p>Note that this changes the subspace. A mere rotation of the basis, which does not change the subspace spanned by it, can be computed using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.basistransform!" href="#KrylovKit.basistransform!"><code>KrylovKit.basistransform!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basistransform!(b::OrthonormalBasis, U::AbstractMatrix)</code></pre><p>Transform the orthonormal basis <code>b</code> by the matrix <code>U</code>. For <code>b</code> an orthonormal basis, the matrix <code>U</code> should be real orthogonal or complex unitary; it is up to the user to ensure this condition is satisfied. The new basis vectors are given by</p><pre><code class="nohighlight hljs">    b[j] ← b[i] * U[i,j]</code></pre><p>and are stored in <code>b</code>, so the old basis vectors are thrown away. Note that, by definition, the subspace spanned by these basis vectors is exactly the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/orthonormal.jl#L290-L303">source</a></section></article><h2 id="Dense-linear-algebra"><a class="docs-heading-anchor" href="#Dense-linear-algebra">Dense linear algebra</a><a id="Dense-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-linear-algebra" title="Permalink"></a></h2><p>KrylovKit relies on Julia&#39;s <code>LinearAlgebra</code> module from the standard library for most of its dense linear algebra dependencies.</p><h2 id="Factorization-types"><a class="docs-heading-anchor" href="#Factorization-types">Factorization types</a><a id="Factorization-types-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization-types" title="Permalink"></a></h2><p>The central ingredient in a Krylov based algorithm is a Krylov factorization or decomposition of a linear map. Such partial factorizations are represented as a <code>KrylovFactorization</code>, of which <code>LanczosFactorization</code> and <code>ArnoldiFactorization</code> are two concrete implementations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.KrylovFactorization" href="#KrylovKit.KrylovFactorization"><code>KrylovKit.KrylovFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type KrylovFactorization{T,S&lt;:Number}</code></pre><p>Abstract type to store a Krylov factorization of a linear map <code>A</code> of the form</p><pre><code class="language-julia hljs">A * V = V * B + r * b&#39;</code></pre><p>For a given Krylov factorization <code>fact</code> of length <code>k = length(fact)</code>, the basis <code>V</code> is obtained via <a href="#KrylovKit.basis"><code>basis(fact)</code></a> and is an instance of some subtype of <a href="#KrylovKit.Basis"><code>Basis{T}</code></a>, with also <code>length(V) == k</code> and where <code>T</code> denotes the type of vector like objects used in the problem. The Rayleigh quotient <code>B</code> is obtained as <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient(fact)</code></a> and <code>typeof(B)</code> is some subtype of <code>AbstractMatrix{S}</code> with <code>size(B) == (k,k)</code>, typically a structured matrix. The residual <code>r</code> is obtained as <a href="#KrylovKit.residual"><code>residual(fact)</code></a> and is of type <code>T</code>. One can also query <a href="#KrylovKit.normres"><code>normres(fact)</code></a> to obtain <code>norm(r)</code>, the norm of the residual. The vector <code>b</code> has no dedicated name and often takes a default form (see below). It should be a subtype of <code>AbstractVector</code> of length <code>k</code> and can be obtained as <a href="#KrylovKit.rayleighextension"><code>rayleighextension(fact)</code></a> (by lack of a better dedicated name).</p><p>A Krylov factorization <code>fact</code> can be destructured as <code>V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p>See also <a href="#KrylovKit.LanczosFactorization"><code>LanczosFactorization</code></a> and <a href="#KrylovKit.ArnoldiFactorization"><code>ArnoldiFactorization</code></a> for concrete implementations, and <a href="#KrylovKit.KrylovIterator"><code>KrylovIterator</code></a> (with in particular <a href="#KrylovKit.LanczosIterator"><code>LanczosIterator</code></a> and <a href="#KrylovKit.ArnoldiIterator"><code>ArnoldiIterator</code></a>) for iterators that construct progressively expanding Krylov factorizations of a given linear map and a starting vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.LanczosFactorization" href="#KrylovKit.LanczosFactorization"><code>KrylovKit.LanczosFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct LanczosFactorization{T,S&lt;:Real} &lt;: KrylovFactorization{T,S}</code></pre><p>Structure to store a Lanczos factorization of a real symmetric or complex hermitian linear map <code>A</code> of the form</p><pre><code class="language-julia hljs">A * V = V * B + r * b&#39;</code></pre><p>For a given Lanczos factorization <code>fact</code> of length <code>k = length(fact)</code>, the basis <code>V</code> is obtained via <a href="#KrylovKit.basis"><code>basis(fact)</code></a> and is an instance of <a href="#KrylovKit.Basis"><code>OrthonormalBasis{T}</code></a>, with also <code>length(V) == k</code> and where <code>T</code> denotes the type of vector like objects used in the problem. The Rayleigh quotient <code>B</code> is obtained as <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient(fact)</code></a> and is of type <code>SymTridiagonal{S&lt;:Real}</code> with <code>size(B) == (k,k)</code>. The residual <code>r</code> is obtained as <a href="#KrylovKit.residual"><code>residual(fact)</code></a> and is of type <code>T</code>. One can also query <a href="#KrylovKit.normres"><code>normres(fact)</code></a> to obtain <code>norm(r)</code>, the norm of the residual. The vector <code>b</code> has no dedicated name but can be obtained via <a href="#KrylovKit.rayleighextension"><code>rayleighextension(fact)</code></a>. It takes the default value <span>$e_k$</span>, i.e. the unit vector of all zeros and a one in the last entry, which is represented using <a href="#KrylovKit.SimpleBasisVector"><code>SimpleBasisVector</code></a>.</p><p>A Lanczos factorization <code>fact</code> can be destructured as <code>V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p><code>LanczosFactorization</code> is mutable because it can <a href="#KrylovKit.expand!"><code>expand!</code></a> or <a href="#KrylovKit.shrink!"><code>shrink!</code></a>. See also <a href="#KrylovKit.LanczosIterator"><code>LanczosIterator</code></a> for an iterator that constructs a progressively expanding Lanczos factorizations of a given linear map and a starting vector. See <a href="#KrylovKit.ArnoldiFactorization"><code>ArnoldiFactorization</code></a> and <a href="#KrylovKit.ArnoldiIterator"><code>ArnoldiIterator</code></a> for a Krylov factorization that works for general (non-symmetric) linear maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/lanczos.jl#L2-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.ArnoldiFactorization" href="#KrylovKit.ArnoldiFactorization"><code>KrylovKit.ArnoldiFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct ArnoldiFactorization{T,S} &lt;: KrylovFactorization{T,S}</code></pre><p>Structure to store an Arnoldi factorization of a linear map <code>A</code> of the form</p><pre><code class="language-julia hljs">A * V = V * B + r * b&#39;</code></pre><p>For a given Arnoldi factorization <code>fact</code> of length <code>k = length(fact)</code>, the basis <code>V</code> is obtained via <a href="#KrylovKit.basis"><code>basis(fact)</code></a> and is an instance of <a href="#KrylovKit.Basis"><code>OrthonormalBasis{T}</code></a>, with also <code>length(V) == k</code> and where <code>T</code> denotes the type of vector like objects used in the problem. The Rayleigh quotient <code>B</code> is obtained as <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient(fact)</code></a> and is of type <a href="#KrylovKit.PackedHessenberg"><code>B::PackedHessenberg{S&lt;:Number}</code></a> with <code>size(B) == (k,k)</code>. The residual <code>r</code> is obtained as <a href="#KrylovKit.residual"><code>residual(fact)</code></a> and is of type <code>T</code>. One can also query <a href="#KrylovKit.normres"><code>normres(fact)</code></a> to obtain <code>norm(r)</code>, the norm of the residual. The vector <code>b</code> has no dedicated name but can be obtained via <a href="#KrylovKit.rayleighextension"><code>rayleighextension(fact)</code></a>. It takes the default value <span>$e_k$</span>, i.e. the unit vector of all zeros and a one in the last entry, which is represented using <a href="#KrylovKit.SimpleBasisVector"><code>SimpleBasisVector</code></a>.</p><p>An Arnoldi factorization <code>fact</code> can be destructured as <code>V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p><code>ArnoldiFactorization</code> is mutable because it can <a href="#KrylovKit.expand!"><code>expand!</code></a> or <a href="#KrylovKit.shrink!"><code>shrink!</code></a>. See also <a href="#KrylovKit.ArnoldiIterator"><code>ArnoldiIterator</code></a> for an iterator that constructs a progressively expanding Arnoldi factorizations of a given linear map and a starting vector. See <a href="#KrylovKit.LanczosFactorization"><code>LanczosFactorization</code></a> and <a href="#KrylovKit.LanczosIterator"><code>LanczosIterator</code></a> for a Krylov factorization that is optimized for real symmetric or complex hermitian linear maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/arnoldi.jl#L2-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.GKLFactorization" href="#KrylovKit.GKLFactorization"><code>KrylovKit.GKLFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct GKLFactorization{TU,TV,S&lt;:Real}</code></pre><p>Structure to store a Golub-Kahan-Lanczos (GKL) bidiagonal factorization of a linear map <code>A</code> of the form</p><pre><code class="language-julia hljs">A * V = U * B + r * b&#39;
A&#39; * U = V * B&#39;</code></pre><p>For a given GKL factorization <code>fact</code> of length <code>k = length(fact)</code>, the two bases <code>U</code> and <code>V</code> are obtained via <a href="#KrylovKit.basis"><code>basis(fact, Val(:U))</code></a> and <code>basis(fact, Val(:V))</code>. Here, <code>U</code> and <code>V</code> are instances of <a href="#KrylovKit.Basis"><code>OrthonormalBasis{T}</code></a>, with also <code>length(U) == length(V) == k</code> and where <code>T</code> denotes the type of vector like objects used in the problem. The Rayleigh quotient <code>B</code> is obtained as <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient(fact)</code></a> and is of type <code>Bidiagonal{S&lt;:Number}</code> with <code>size(B) == (k,k)</code>. The residual <code>r</code> is obtained as <a href="#KrylovKit.residual"><code>residual(fact)</code></a> and is of type <code>T</code>. One can also query <a href="#KrylovKit.normres"><code>normres(fact)</code></a> to obtain <code>norm(r)</code>, the norm of the residual. The vector <code>b</code> has no dedicated name but can be obtained via <a href="#KrylovKit.rayleighextension"><code>rayleighextension(fact)</code></a>. It takes the default value <span>$e_k$</span>, i.e. the unit vector of all zeros and a one in the last entry, which is represented using <a href="#KrylovKit.SimpleBasisVector"><code>SimpleBasisVector</code></a>.</p><p>A GKL factorization <code>fact</code> can be destructured as <code>U, V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p><code>GKLFactorization</code> is mutable because it can <a href="#KrylovKit.expand!"><code>expand!</code></a> or <a href="#KrylovKit.shrink!"><code>shrink!</code></a>. See also <a href="#KrylovKit.GKLIterator"><code>GKLIterator</code></a> for an iterator that constructs a progressively expanding GKL factorizations of a given linear map and a starting vector <code>u₀</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/gkl.jl#L2-L31">source</a></section></article><p>A <code>KrylovFactorization</code> or <code>GKLFactorization</code> can be destructured into its defining components using iteration, but these can also be accessed using the following functions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.basis" href="#KrylovKit.basis"><code>KrylovKit.basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    basis(fact::KrylovFactorization)</code></pre><p>Return the list of basis vectors of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which span the Krylov subspace. The return type is a subtype of <code>Basis{T}</code>, where <code>T</code> represents the type of the vectors used by the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.rayleighquotient" href="#KrylovKit.rayleighquotient"><code>KrylovKit.rayleighquotient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rayleighquotient(fact::KrylovFactorization)</code></pre><p>Return the Rayleigh quotient of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, i.e. the reduced matrix within the basis of the Krylov subspace. The return type is a subtype of <code>AbstractMatrix{&lt;:Number}</code>, typically some structured matrix type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.residual" href="#KrylovKit.residual"><code>KrylovKit.residual</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual(fact::KrylovFactorization)</code></pre><p>Return the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. The return type is some vector of the same type as used in the problem. See also <a href="#KrylovKit.normres"><code>normres(F)</code></a> for its norm, which typically has been computed already.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.normres" href="#KrylovKit.normres"><code>KrylovKit.normres</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normres(fact::KrylovFactorization)</code></pre><p>Return the norm of the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. As this has typically already been computed, it is cheaper than (but otherwise equivalent to) <code>norm(residual(F))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.rayleighextension" href="#KrylovKit.rayleighextension"><code>KrylovKit.rayleighextension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rayleighextension(fact::KrylovFactorization)</code></pre><p>Return the vector <code>b</code> appearing in the definition of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>; often it is simply the last coordinate unit vector, which can be represented using <a href="#KrylovKit.SimpleBasisVector"><code>SimpleBasisVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L83-L89">source</a></section></article><p>As the <code>rayleighextension</code> is typically a simple basis vector, we have created a dedicated type to represent this without having to allocate an actual vector, i.e.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.SimpleBasisVector" href="#KrylovKit.SimpleBasisVector"><code>KrylovKit.SimpleBasisVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleBasisVector(m, k)</code></pre><p>Construct a simple struct <code>SimpleBasisVector &lt;: AbstractVector{Bool}</code> representing a coordinate basis vector of length <code>m</code> in the direction of <code>k</code>, i.e. for <code>e_k = SimpleBasisVector(m, k)</code> we have <code>length(e_k) = m</code> and <code>e_k[i] = (i == k)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/KrylovKit.jl#L124-L130">source</a></section></article><p>Furthermore, to store the Rayleigh quotient of the Arnoldi factorization in a manner that can easily be expanded, we have constructed a custom matrix type to store the Hessenberg matrix in a packed format (without zeros):</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.PackedHessenberg" href="#KrylovKit.PackedHessenberg"><code>KrylovKit.PackedHessenberg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PackedHessenberg{T,V&lt;:AbstractVector{T}} &lt;: AbstractMatrix{T}
    data::V
    n::Int
end</code></pre><p>A custom struct to store a Hessenberg matrix in a packed format (without zeros). Hereto, the non-zero entries are stored sequentially in vector <code>data</code> of length <code>n(n+1)/2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/dense/packedhessenberg.jl#L1-L9">source</a></section></article><h2 id="Factorization-iterators"><a class="docs-heading-anchor" href="#Factorization-iterators">Factorization iterators</a><a id="Factorization-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization-iterators" title="Permalink"></a></h2><p>Given a linear map <span>$A$</span> and a starting vector <span>$x₀$</span>, a Krylov factorization is obtained by sequentially building a Krylov subspace <span>${x₀, A x₀, A² x₀, ...}$</span>. Rather then using this set of vectors as a basis, an orthonormal basis is generated by a process known as Lanczos or Arnoldi iteration (for symmetric/hermitian and for general matrices, respectively). These processes are represented as iterators in Julia:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.KrylovIterator" href="#KrylovKit.KrylovIterator"><code>KrylovKit.KrylovIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type KrylovIterator{F,T}</code></pre><p>Abstract type for iterators that take a linear map of type <code>F</code> and an initial vector of type <code>T</code> and generate an expanding <code>KrylovFactorization</code> thereof.</p><p>When iterating over an instance of <code>KrylovIterator</code>, the values being generated are subtypes of <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>.</p><p>See <a href="#KrylovKit.LanczosIterator"><code>LanczosIterator</code></a> and <a href="#KrylovKit.ArnoldiIterator"><code>ArnoldiIterator</code></a> for concrete implementations and more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.LanczosIterator" href="#KrylovKit.LanczosIterator"><code>KrylovKit.LanczosIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LanczosIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}
LanczosIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth, keepvecs::Bool = true])</code></pre><p>Iterator that takes a linear map <code>f::F</code> (supposed to be real symmetric or complex hermitian) and an initial vector <code>v₀::T</code> and generates an expanding <code>LanczosFactorization</code> thereof. In particular, <code>LanczosIterator</code> uses the <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm">Lanczos iteration</a> scheme to build a successively expanding Lanczos factorization. While <code>f</code> cannot be tested to be symmetric or hermitian directly when the linear map is encoded as a general callable object or function, it is tested whether the imaginary part of <code>inner(v, f(v))</code> is sufficiently small to be neglected.</p><p>The argument <code>f</code> can be a matrix, or a function accepting a single argument <code>v</code>, so that <code>f(v)</code> implements the action of the linear map on the vector <code>v</code>.</p><p>The optional argument <code>orth</code> specifies which <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> to be used. The default value in <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> is to use <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>, which possibly uses reorthogonalization steps. One can use to discard the old vectors that span the Krylov subspace by setting the final argument <code>keepvecs</code> to <code>false</code>. This, however, is only possible if an <code>orth</code> algorithm is used that does not rely on reorthogonalization, such as <code>ClassicalGramSchmidt()</code> or <code>ModifiedGramSchmidt()</code>. In that case, the iterator strictly uses the Lanczos three-term recurrence relation.</p><p>When iterating over an instance of <code>LanczosIterator</code>, the values being generated are instances of <a href="#KrylovKit.LanczosFactorization"><code>LanczosFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>, for example as</p><pre><code class="language-julia hljs">for (V, B, r, nr, b) in LanczosIterator(f, v₀)
    # do something
    nr &lt; tol &amp;&amp; break # a typical stopping criterion
end</code></pre><p>Note, however, that if <code>keepvecs=false</code> in <code>LanczosIterator</code>, the basis <code>V</code> cannot be extracted.</p><p>Since the iterator does not know the dimension of the underlying vector space of objects of type <code>T</code>, it keeps expanding the Krylov subspace until the residual norm <code>nr</code> falls below machine precision <code>eps(typeof(nr))</code>.</p><p>The internal state of <code>LanczosIterator</code> is the same as the return value, i.e. the corresponding <code>LanczosFactorization</code>. However, as Julia&#39;s Base iteration interface (using <code>Base.iterate</code>) requires that the state is not mutated, a <code>deepcopy</code> is produced upon every next iteration step.</p><p>Instead, you can also mutate the <code>KrylovFactorization</code> in place, using the following interface, e.g. for the same example above</p><pre><code class="language-julia hljs">iterator = LanczosIterator(f, v₀)
factorization = initialize(iterator)
while normres(factorization) &gt; tol
    expand!(iterator, factorization)
    V, B, r, nr, b = factorization
    # do something
end</code></pre><p>Here, <a href="#KrylovKit.initialize"><code>initialize(::KrylovIterator)</code></a> produces the first Krylov factorization of length 1, and <code>expand!(::KrylovIterator, ::KrylovFactorization)</code>(@ref) expands the factorization in place. See also <a href="#KrylovKit.initialize!"><code>initialize!(::KrylovIterator, ::KrylovFactorization)</code></a> to initialize in an already existing factorization (most information will be discarded) and <a href="#KrylovKit.shrink!"><code>shrink!(::KrylovFactorization, k)</code></a> to shrink an existing factorization down to length <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/lanczos.jl#L60-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.ArnoldiIterator" href="#KrylovKit.ArnoldiIterator"><code>KrylovKit.ArnoldiIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ArnoldiIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}
ArnoldiIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth])</code></pre><p>Iterator that takes a general linear map <code>f::F</code> and an initial vector <code>v₀::T</code> and generates an expanding <code>ArnoldiFactorization</code> thereof. In particular, <code>ArnoldiIterator</code> iterates over progressively expanding Arnoldi factorizations using the <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi iteration</a>.</p><p>The argument <code>f</code> can be a matrix, or a function accepting a single argument <code>v</code>, so that <code>f(v)</code> implements the action of the linear map on the vector <code>v</code>.</p><p>The optional argument <code>orth</code> specifies which <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> to be used. The default value in <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> is to use <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>, which possibly uses reorthogonalization steps.</p><p>When iterating over an instance of <code>ArnoldiIterator</code>, the values being generated are instances of <a href="#KrylovKit.ArnoldiFactorization"><code>ArnoldiFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>, for example as</p><pre><code class="language-julia hljs">for (V, B, r, nr, b) in ArnoldiIterator(f, v₀)
    # do something
    nr &lt; tol &amp;&amp; break # a typical stopping criterion
end</code></pre><p>Since the iterator does not know the dimension of the underlying vector space of objects of type <code>T</code>, it keeps expanding the Krylov subspace until the residual norm <code>nr</code> falls below machine precision <code>eps(typeof(nr))</code>.</p><p>The internal state of <code>ArnoldiIterator</code> is the same as the return value, i.e. the corresponding <code>ArnoldiFactorization</code>. However, as Julia&#39;s Base iteration interface (using <code>Base.iterate</code>) requires that the state is not mutated, a <code>deepcopy</code> is produced upon every next iteration step.</p><p>Instead, you can also mutate the <code>ArnoldiFactorization</code> in place, using the following interface, e.g. for the same example above</p><pre><code class="language-julia hljs">iterator = ArnoldiIterator(f, v₀)
factorization = initialize(iterator)
while normres(factorization) &gt; tol
    expand!(iterator, factorization)
    V, B, r, nr, b = factorization
    # do something
end</code></pre><p>Here, <a href="#KrylovKit.initialize"><code>initialize(::KrylovIterator)</code></a> produces the first Krylov factorization of length 1, and <code>expand!(::KrylovIterator, ::KrylovFactorization)</code>(@ref) expands the factorization in place. See also <a href="#KrylovKit.initialize!"><code>initialize!(::KrylovIterator, ::KrylovFactorization)</code></a> to initialize in an already existing factorization (most information will be discarded) and <a href="#KrylovKit.shrink!"><code>shrink!(::KrylovFactorization, k)</code></a> to shrink an existing factorization down to length <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/arnoldi.jl#L55-L111">source</a></section></article><p>Similarly, there is also an iterator for the Golub-Kahan-Lanczos bidiagonalization proces:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.GKLIterator" href="#KrylovKit.GKLIterator"><code>KrylovKit.GKLIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GKLIterator{F,TU,O&lt;:Orthogonalizer}
GKLIterator(f, u₀, [orth::Orthogonalizer = KrylovDefaults.orth, keepvecs::Bool = true])</code></pre><p>Iterator that takes a general linear map <code>f::F</code> and an initial vector <code>u₀::TU</code> and generates an expanding <code>GKLFactorization</code> thereof. In particular, <code>GKLIterator</code> implements the <a href="http://www.netlib.org/utk/people/JackDongarra/etemplates/node198.html">Golub-Kahan-Lanczos bidiagonalization procedure</a>. Note, however, that this implementation starts from a vector <code>u₀</code> in the codomain of the linear map <code>f</code>, which will end up (after normalisation) as the first column of <code>U</code>.</p><p>The argument <code>f</code> can be a matrix, a tuple of two functions where the first represents the normal action and the second the adjoint action, or a function accepting two arguments, where the first argument is the vector to which the linear map needs to be applied, and the second argument is either <code>Val(false)</code> for the normal action and <code>Val(true)</code> for the adjoint action. Note that the flag is thus a <code>Val</code> type to allow for type stability in cases where the vectors in the domain and the codomain of the linear map have a different type.</p><p>The optional argument <code>orth</code> specifies which <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a> to be used. The default value in <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> is to use <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>, which possibly uses reorthogonalization steps.</p><p>When iterating over an instance of <code>GKLIterator</code>, the values being generated are instances <code>fact</code> of <a href="#KrylovKit.GKLFactorization"><code>GKLFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis(fact, Val(:U))</code></a>, <a href="#KrylovKit.basis"><code>basis(fact, Val(:V))</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>, for example as</p><pre><code class="language-julia hljs">for (U, V, B, r, nr, b) in GKLIterator(f, u₀)
    # do something
    nr &lt; tol &amp;&amp; break # a typical stopping criterion
end</code></pre><p>Since the iterator does not know the dimension of the underlying vector space of objects of type <code>T</code>, it keeps expanding the Krylov subspace until the residual norm <code>nr</code> falls below machine precision <code>eps(typeof(nr))</code>.</p><p>The internal state of <code>GKLIterator</code> is the same as the return value, i.e. the corresponding <code>GKLFactorization</code>. However, as Julia&#39;s Base iteration interface (using <code>Base.iterate</code>) requires that the state is not mutated, a <code>deepcopy</code> is produced upon every next iteration step.</p><p>Instead, you can also mutate the <code>GKLFactorization</code> in place, using the following interface, e.g. for the same example above</p><pre><code class="language-julia hljs">iterator = GKLIterator(f, u₀)
factorization = initialize(iterator)
while normres(factorization) &gt; tol
    expand!(iterator, factorization)
    U, V, B, r, nr, b = factorization
    # do something
end</code></pre><p>Here, <a href="#KrylovKit.initialize"><code>initialize(::GKLIterator)</code></a> produces the first GKL factorization of length 1, and <code>expand!(::GKLIterator, ::GKLFactorization)</code>(@ref) expands the factorization in place. See also <a href="#KrylovKit.initialize!"><code>initialize!(::GKLIterator, ::GKLFactorization)</code></a> to initialize in an already existing factorization (most information will be discarded) and <a href="#KrylovKit.shrink!"><code>shrink!(::GKLIterator, k)</code></a> to shrink an existing factorization down to length <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/gkl.jl#L86-L146">source</a></section></article><p>As an alternative to the standard iteration interface from Julia Base (using <code>iterate</code>), these iterative processes and the factorizations they produce can also be manipulated using the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.expand!" href="#KrylovKit.expand!"><code>KrylovKit.expand!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expand!(iter::KrylovIterator, fact::KrylovFactorization)</code></pre><p>Expand the Krylov factorization <code>fact</code> by one using the linear map and parameters in <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.shrink!" href="#KrylovKit.shrink!"><code>KrylovKit.shrink!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shrink!(fact::KrylovFactorization, k)</code></pre><p>Shrink an existing Krylov factorization <code>fact</code> down to have length <code>k</code>. Does nothing if <code>length(fact)&lt;=k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.initialize" href="#KrylovKit.initialize"><code>KrylovKit.initialize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize(iter::KrylovIterator)</code></pre><p>Initialize a length 1 Krylov factorization corresponding to <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.initialize!" href="#KrylovKit.initialize!"><code>KrylovKit.initialize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize!(iter::KrylovIterator, fact::KrylovFactorization)</code></pre><p>Initialize a length 1 Krylov factorization corresponding to <code>iter</code> in the already existing factorization <code>fact</code>, thereby destroying all the information it currently holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/fb56bbc7ee952bc8a6af6d278c42e78e553aa62e/src/factorizations/krylov.jl#L107-L112">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithms/">« Available algorithms</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 24 January 2025 08:15">Friday 24 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
