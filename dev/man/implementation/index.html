<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Details of the implementation · KrylovKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">KrylovKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../linear/">Linear problems</a></li><li><a class="tocitem" href="../eig/">Eigenvalue problems</a></li><li><a class="tocitem" href="../svd/">Singular value problems</a></li><li><a class="tocitem" href="../matfun/">Functions of matrices and linear maps</a></li><li><a class="tocitem" href="../algorithms/">Available algorithms</a></li><li class="is-active"><a class="tocitem" href>Details of the implementation</a><ul class="internal"><li><a class="tocitem" href="#Orthogonalization"><span>Orthogonalization</span></a></li><li><a class="tocitem" href="#Dense-linear-algebra"><span>Dense linear algebra</span></a></li><li><a class="tocitem" href="#Krylov-factorizations"><span>Krylov factorizations</span></a></li><li><a class="tocitem" href="#Krylov-iterators"><span>Krylov iterators</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Details of the implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Details of the implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/implementation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Details-of-the-implementation"><a class="docs-heading-anchor" href="#Details-of-the-implementation">Details of the implementation</a><a id="Details-of-the-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Details-of-the-implementation" title="Permalink"></a></h1><h2 id="Orthogonalization"><a class="docs-heading-anchor" href="#Orthogonalization">Orthogonalization</a><a id="Orthogonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonalization" title="Permalink"></a></h2><p>To denote a basis of vectors, e.g. to represent a given Krylov subspace, there is an abstract type <code>Basis{T}</code></p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.Basis" href="#KrylovKit.Basis"><code>KrylovKit.Basis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Basis{T} end</code></pre><p>An abstract type to collect specific types for representing a basis of vectors of type <code>T</code>.</p><p>Implementations of <code>Basis{T}</code> behave in many ways like <code>Vector{T}</code> and should have a <code>length</code>, can be indexed (<code>getindex</code> and <code>setindex!</code>), iterated over (<code>iterate</code>), and support resizing (<code>resize!</code>, <code>pop!</code>, <code>push!</code>, <code>empty!</code>, <code>sizehint!</code>).</p><p>The type <code>T</code> denotes the type of the elements stored in an <code>Basis{T}</code> and can be any custom type that has vector like behavior (as defined in the docs of <a href="man/@ref"><code>KrylovKit</code></a>).</p><p>See <a href="#KrylovKit.OrthonormalBasis"><code>OrthonormalBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L39-L51">source</a></section></article><p>Many Krylov based algorithms use an orthogonal basis to parameterize the Krylov subspace. In that case, the specific implementation <code>OrthonormalBasis{T}</code> can be used:</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.OrthonormalBasis" href="#KrylovKit.OrthonormalBasis"><code>KrylovKit.OrthonormalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrthonormalBasis{T} &lt;: Basis{T}</code></pre><p>A list of vector like objects of type <code>T</code> that are mutually orthogonal and normalized to one, representing an orthonormal basis for some subspace (typically a Krylov subspace). See also <a href="#KrylovKit.Basis"><code>Basis</code></a></p><p>Orthonormality of the vectors contained in an instance <code>b</code> of <code>OrthonormalBasis</code> (i.e. <code>all(dot(b[i],b[j]) == I[i,j] for i=1:length(b), j=1:length(b))</code>) is not checked when elements are added; it is up to the algorithm that constructs <code>b</code> to guarantee orthonormality.</p><p>One can easily orthogonalize or orthonormalize a given vector <code>v</code> with respect to a <code>b::OrthonormalBasis</code> using the functions <a href="#KrylovKit.orthogonalize"><code>w, = orthogonalize(v,b,...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>w, = orthonormalize(v,b,...)</code></a>. The resulting vector <code>w</code> of the latter can then be added to <code>b</code> using <code>push!(b, w)</code>. Note that in place versions <a href="#KrylovKit.orthogonalize"><code>orthogonalize!(v, b, ...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>orthonormalize!(v, b, ...)</code></a> are also available.</p><p>Finally, a linear combination of the vectors in <code>b::OrthonormalBasis</code> can be obtained by multiplying <code>b</code> with a <code>Vector{&lt;:Number}</code> using <code>*</code> or <code>mul!</code> (if the output vector is already allocated).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/orthonormal.jl#L2-L21">source</a></section></article><p>We can orthogonalize or orthonormalize a given vector to another vector (assumed normalized) or to a given <a href="man/@ref"><code>OrthonormalBasis</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.orthogonalize" href="#KrylovKit.orthogonalize"><code>KrylovKit.orthogonalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">orthogonalize(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, x
orthogonalize!(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, x

orthogonalize(v, q, algorithm::Orthogonalizer]) -&gt; w, s
orthogonalize!(v, q, algorithm::Orthogonalizer]) -&gt; w, s</code></pre><p>Orthogonalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>algorithm</code>, and return the resulting vector <code>w</code> and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthogonalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthogonal vector <code>w</code> and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>Note that <code>w</code> is not normalized, see also <a href="#KrylovKit.orthonormalize"><code>orthonormalize</code></a>.</p><p>For algorithms, see <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/orthonormal.jl#L369-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.orthonormalize" href="#KrylovKit.orthonormalize"><code>KrylovKit.orthonormalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">orthonormalize(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, β, x
orthonormalize!(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, β, x

orthonormalize(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s
orthonormalize!(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s</code></pre><p>Orthonormalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>algorithm</code>, and return the resulting vector <code>w</code> (of norm 1), its norm <code>β</code> after orthogonalizing and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>, such that <code>v = β * w + b * x</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthonormalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthonormal vector <code>w</code>, its norm <code>β</code> before normalizing and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>See <a href="#KrylovKit.orthogonalize"><code>orthogonalize</code></a> if <code>w</code> does not need to be normalized.</p><p>For algorithms, see <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/orthonormal.jl#L404-L428">source</a></section></article><h2 id="Dense-linear-algebra"><a class="docs-heading-anchor" href="#Dense-linear-algebra">Dense linear algebra</a><a id="Dense-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-linear-algebra" title="Permalink"></a></h2><p>KrylovKit relies on Julia&#39;s <code>LinearAlgebra</code> module from the standard library for most of its dense linear algebra dependencies.</p><h2 id="Krylov-factorizations"><a class="docs-heading-anchor" href="#Krylov-factorizations">Krylov factorizations</a><a id="Krylov-factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-factorizations" title="Permalink"></a></h2><p>The central ingredient in a Krylov based algorithm is a Krylov factorization or decomposition of a linear map. Such partial factorizations are represented as a <code>KrylovFactorization</code>, of which <code>LanczosFactorization</code> and <code>ArnoldiFactorization</code> are two concrete implementations:</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.KrylovFactorization" href="#KrylovKit.KrylovFactorization"><code>KrylovKit.KrylovFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type KrylovFactorization{T,S&lt;:Number}
mutable struct LanczosFactorization{T,S&lt;:Real}    &lt;: KrylovFactorization{T,S}
mutable struct ArnoldiFactorization{T,S&lt;:Number}  &lt;: KrylovFactorization{T,S}</code></pre><p>Structures to store a Krylov factorization of a linear map <code>A</code> of the form</p><pre><code class="language-julia">    A * V = V * B + r * b&#39;.</code></pre><p>For a given Krylov factorization <code>fact</code> of length <code>k = length(fact)</code>, the basis <code>A is obtained via [</code>basis(fact)<code>](@ref basis) and is an instance of some subtype of [</code>Basis{T}<code>](@ref Basis), with also</code>length(V) == k<code>and where</code>T<code>denotes the type of vector like objects used in the problem. The Rayleigh quotient</code>B<code>is obtained as [</code>rayleighquotient(fact)<code>](@ref) and</code>typeof(B)<code>is some subtype of</code>AbstractMatrix{S}<code>with</code>size(B) == (k,k)<code>, typically a structured matrix. The residual</code>r<code>is obtained as [</code>residual(fact)<code>](@ref) and is of type</code>T<code>. One can also query [</code>normres(fact)<code>](@ref) to obtain</code>norm(r)<code>, the norm of the residual. The vector</code>b<code>has no dedicated name and often takes a default form (see below). It should be a subtype of</code>AbstractVector<code>of length</code>k<code>and can be obtained as [</code>rayleighextension(fact)`](@ref) (by lack of a better dedicated name).</p><p>In particular, <code>LanczosFactorization</code> stores a Lanczos factorization of a real symmetric or complex hermitian linear map and has <code>V::OrthonormalBasis{T}</code> and <code>B::SymTridiagonal{S&lt;:Real}</code>. <code>ArnoldiFactorization</code> stores an Arnoldi factorization of a general linear map and has <code>V::OrthonormalBasis{T}</code> and <a href="man/@ref PackedHessenberg"><code>B::PackedHessenberg{S&lt;:Number}</code></a>. In both cases, <code>b</code> takes the default value <span>$e_k$</span>, i.e. the unit vector of all zeros and a one in the last entry, which is represented using <a href="man/@ref"><code>SimpleBasisVector</code></a>.</p><p>A Krylov factorization <code>fact</code> can be destructured as <code>V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p><code>LanczosFactorization</code> and <code>ArnoldiFactorization</code> are mutable because they can <a href="#KrylovKit.expand!"><code>expand!</code></a> or <a href="#KrylovKit.shrink!"><code>shrink!</code></a>. See also <a href="#KrylovKit.KrylovIterator"><code>KrylovIterator</code></a> (and in particular <a href="man/@ref"><code>LanczosIterator</code></a> and <a href="man/@ref"><code>ArnoldiIterator</code></a>) for iterators that construct progressively expanding Krylov factorizations of a given linear map and a starting vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L181-L217">source</a></section></article><p>A <code>KrylovFactorization</code> can be destructured into its defining components using iteration, but these can also be accessed using the following functions</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.basis" href="#KrylovKit.basis"><code>KrylovKit.basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    basis(fact::KrylovFactorization)</code></pre><p>Return the list of basis vectors of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which span the Krylov subspace. The return type is a subtype of <code>Basis{T}</code>, where <code>T</code> represents the type of the vectors used by the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.rayleighquotient" href="#KrylovKit.rayleighquotient"><code>KrylovKit.rayleighquotient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rayleighquotient(fact::KrylovFactorization)</code></pre><p>Return the Rayleigh quotient of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, i.e. the reduced matrix within the basis of the Krylov subspace. The return type is a subtype of <code>AbstractMatrix{&lt;:Number}</code>, typically some structured matrix type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.residual" href="#KrylovKit.residual"><code>KrylovKit.residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">residual(fact::KrylovFactorization)</code></pre><p>Return the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. The return type is some vector of the same type as used in the problem. See also <a href="#KrylovKit.normres"><code>normres(F)</code></a> for its norm, which typically has been computed already.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.normres" href="#KrylovKit.normres"><code>KrylovKit.normres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normres(fact::KrylovFactorization)</code></pre><p>Return the norm of the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. As this has typically already been computed, it is cheaper than (but otherwise equivalent to) <code>norm(residual(F))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.rayleighextension" href="#KrylovKit.rayleighextension"><code>KrylovKit.rayleighextension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rayleighextension(fact::KrylovFactorization)</code></pre><p>Return the vector <code>b</code> appearing in the definition of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L119-L123">source</a></section></article><h2 id="Krylov-iterators"><a class="docs-heading-anchor" href="#Krylov-iterators">Krylov iterators</a><a id="Krylov-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-iterators" title="Permalink"></a></h2><p>Given a linear map <span>$A$</span> and a starting vector <span>$x₀$</span>, a Krylov factorization is obtained by sequentially building a Krylov subspace <span>${x₀, A x₀, A² x₀, ...}$</span>. Rather then using this set of vectors as a basis, an orthonormal basis is generated by a process known as Lanczos or Arnoldi iteration (for symmetric/hermitian and for general matrices, respectively). These processes are represented as iterators in Julia:</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.KrylovIterator" href="#KrylovKit.KrylovIterator"><code>KrylovKit.KrylovIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type KrylovIterator{F,T}
struct LanczosIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}
struct ArnoldiIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}

LanczosIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth], keepvecs::Bool = true)
ArnoldiIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth])</code></pre><p>Iterators that take a linear map of type <code>F</code> and an initial vector of type <code>T</code> and generate an expanding <code>KrylovFactorization</code> thereof.</p><p>In particular, for a real symmetric or complex hermitian linear map <code>f</code>, <code>LanczosIterator</code> uses the <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm">Lanczos iteration</a> scheme to build a successively expanding <code>LanczosFactorization</code>. While <code>f</code> cannot be tested to be symmetric or hermitian directly when the linear map is encoded as a general callable object or function, it is tested whether the imaginary part of <code>dot(v, f(v))</code> is sufficiently small to be neglected.</p><p>Similarly, for a general linear map <code>f</code>, <code>ArnoldiIterator</code> iterates over progressively expanding <code>ArnoldiFactorizations</code> using the <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi iteration</a>.</p><p>The optional argument <code>orth</code> specifies which <a href="man/@ref"><code>Orthogonalizer</code></a> to be used. The default value in <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> is to use <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>, which possibly uses reorthogonalization steps. For <code>LanczosIterator</code>, one can use to discard the old vectors that span the Krylov subspace by setting the final argument <code>keepvecs</code> to <code>false</code>. This, however, is only possible if an <code>orth</code> algorithm is used that does not rely on reorthogonalization, such as <code>ClassicalGramSchmidt()</code> or <code>ModifiedGramSchmidt()</code>. In that case, the iterator strictly uses the Lanczos three-term recurrence relation.</p><p>When iterating over an instance of <code>KrylovIterator</code>, the values being generated are subtypes of <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>, for example as</p><pre><code class="language-julia">for (V,B,r,nr,b) in ArnoldiIterator(f, v₀)
    # do something
    nr &lt; tol &amp;&amp; break # a typical stopping criterion
end</code></pre><p>Note, however, that if <code>keepvecs=false</code> in <code>LanczosIterator</code>, the basis <code>V</code> cannot be extracted. Since the iterators don&#39;t know the dimension of the underlying vector space of objects of type <code>T</code>, they keep expanding the Krylov subspace until <code>normres</code> falls below machine precision <code>eps</code> for the given <code>eltype(T)</code>.</p><p>The internal state of <code>LanczosIterator</code> and <code>ArnoldiIterator</code> is the same as the return value, i.e. the corresponding <code>LanczosFactorization</code> or <code>ArnoldiFactorization</code>. However, as Julia&#39;s Base iteration interface (using <code>Base.iterate</code>) requires that the state is not mutated, a <code>deepcopy</code> is produced upon every next iteration step.</p><p>Instead, you can also mutate the <code>KrylovFactorization</code> in place, using the following interface, e.g. for the same example above</p><pre><code class="language-julia">iterator = ArnoldiIterator(f, v₀)
factorization = initialize(iterator)
while normres(factorization) &gt; tol
    expand!(iterator, factorization)
    V,B,r,nr,b = factorization
    # do something
end</code></pre><p>Here, <a href="#KrylovKit.initialize"><code>initialize(::KrylovIterator)</code></a> produces the first Krylov factorization of length 1, and <code>expand!(::KrylovIterator, ::KrylovFactorization)</code>(@ref) expands the factorization in place. See also <a href="#KrylovKit.initialize!"><code>initialize!(::KrylovIterator,::KrylovFactorization)</code></a> to initialize in an already existing factorization (most information will be discarded) and <a href="#KrylovKit.shrink!"><code>shrink!(::KrylovFactorization, k)</code></a> to shrink an existing factorization down to length <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L220-L288">source</a></section></article><p>The following functions allow to manipulate a <code>KrylovFactorization</code> obtained from such a <code>KrylovIterator</code>:</p><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.expand!" href="#KrylovKit.expand!"><code>KrylovKit.expand!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand!(iter::KrylovIterator, fact::KrylovFactorization)</code></pre><p>Expand the Krylov factorization <code>fact</code> by one using the linear map and parameters in <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.shrink!" href="#KrylovKit.shrink!"><code>KrylovKit.shrink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shrink!(fact::KrylovFactorization, k)</code></pre><p>Shrink an existing Krylov factorization <code>fact</code> down to have length <code>k</code>. Does nothing if <code>length(fact)&lt;=k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.initialize!" href="#KrylovKit.initialize!"><code>KrylovKit.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize!(iter::KrylovIterator, fact::KrylovFactorization)</code></pre><p>Initialize a length 1 Krylov factorization corresponding to <code>iter</code> in the already existing factorization <code>fact</code>, thereby destroying all the information it currently holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KrylovKit.initialize" href="#KrylovKit.initialize"><code>KrylovKit.initialize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize(iter::KrylovIterator)</code></pre><p>Initialize a length 1 Krylov factorization corresponding to <code>iter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/af492ee13667de83f9bfbcdea6faf7782b43d115/src/KrylovKit.jl#L149-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithms/">« Available algorithms</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 14 July 2021 20:24">Wednesday 14 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
