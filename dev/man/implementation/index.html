<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Details of the implementation · KrylovKit.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>KrylovKit.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../linear/">Linear problems</a></li><li><a class="toctext" href="../eig/">Eigenvalue problems</a></li><li><a class="toctext" href="../svd/">Singular value problems</a></li><li><a class="toctext" href="../matfun/">Functions of matrices and linear maps</a></li><li><a class="toctext" href="../algorithms/">Available algorithms</a></li><li class="current"><a class="toctext" href>Details of the implementation</a><ul class="internal"><li><a class="toctext" href="#Orthogonalization-1">Orthogonalization</a></li><li><a class="toctext" href="#Dense-linear-algebra-1">Dense linear algebra</a></li><li><a class="toctext" href="#Krylov-factorizations-1">Krylov factorizations</a></li><li><a class="toctext" href="#Krylov-iterators-1">Krylov iterators</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Details of the implementation</a></li></ul><a class="edit-page" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/implementation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Details of the implementation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Details-of-the-implementation-1" href="#Details-of-the-implementation-1">Details of the implementation</a></h1><h2><a class="nav-anchor" id="Orthogonalization-1" href="#Orthogonalization-1">Orthogonalization</a></h2><p>To denote a basis of vectors, e.g. to represent a given Krylov subspace, there is an abstract type <code>Basis{T}</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.Basis" href="#KrylovKit.Basis"><code>KrylovKit.Basis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type Basis{T} end</code></pre><p>An abstract type to collect specific types for representing a basis of vectors of type <code>T</code>.</p><p>Implementations of <code>Basis{T}</code> behave in many ways like <code>Vector{T}</code> and should have a <code>length</code>, can be indexed (<code>getindex</code> and <code>setindex!</code>), iterated over (<code>iterate</code>), and support resizing (<code>resize!</code>, <code>pop!</code>, <code>push!</code>, <code>empty!</code>, <code>sizehint!</code>).</p><p>The type <code>T</code> denotes the type of the elements stored in an <code>Basis{T}</code> and can be any custom type that has vector like behavior (as defined in the docs of <a href="man/@ref"><code>KrylovKit</code></a>).</p><p>See <a href="#KrylovKit.OrthonormalBasis"><code>OrthonormalBasis</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L39-L51">source</a></section><p>Many Krylov based algorithms use an orthogonal basis to parametrize the Krylov subspace. In that case, the specific implementation <code>OrthonormalBasis{T}</code> can be used:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.OrthonormalBasis" href="#KrylovKit.OrthonormalBasis"><code>KrylovKit.OrthonormalBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrthonormalBasis{T} &lt;: Basis{T}</code></pre><p>A list of vector like objects of type <code>T</code> that are mutually orthogonal and normalized to one, representing an orthonormal basis for some subspace (typically a Krylov subspace). See also <a href="#KrylovKit.Basis"><code>Basis</code></a></p><p>Orthonormality of the vectors contained in an instance <code>b</code> of <code>OrthonormalBasis</code> (i.e. <code>all(dot(b[i],b[j]) == I[i,j] for i=1:lenght(b), j=1:length(b))</code>) is not checked when elements are added; it is up to the algorithm that constructs <code>b</code> to guarantee orthonormality.</p><p>One can easily orthogonalize or orthonormalize a given vector <code>v</code> with respect to a <code>b::OrthonormalBasis</code> using the functions <a href="#KrylovKit.orthogonalize"><code>w, = orthogonalize(v,b,...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>w, = orthonormalize(v,b,...)</code></a>. The resulting vector <code>w</code> of the latter can then be added to <code>b</code> using <code>push!(b, w)</code>. Note that in place versions <a href="#KrylovKit.orthogonalize"><code>orthogonalize!(v, b, ...)</code></a> or <a href="#KrylovKit.orthonormalize"><code>orthonormalize!(v, b, ...)</code></a> are also available.</p><p>Finally, a linear combination of the vectors in <code>b::OrthonormalBasis</code> can be obtained by multiplying <code>b</code> with a <code>Vector{&lt;:Number}</code> using <code>*</code> or <code>mul!</code> (if the output vector is already allocated).</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/orthonormal.jl#L2-L21">source</a></section><p>We can orthogonalize or orthonormalize a given vector to another vector (assumed normalized) or to a given <a href="man/@ref"><code>OrthonormalBasis</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.orthogonalize" href="#KrylovKit.orthogonalize"><code>KrylovKit.orthogonalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orthogonalize(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, x
orthogonalize!(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, x

orthogonalize(v, q, algorithm::Orthogonalizer]) -&gt; w, s
orthogonalize!(v, q, algorithm::Orthogonalizer]) -&gt; w, s</code></pre><p>Orthogonalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>algorithm</code>, and return the resulting vector <code>w</code> and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthogonalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthogonal vector <code>w</code> and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>Note that <code>w</code> is not normalized, see also <a href="#KrylovKit.orthonormalize"><code>orthonormalize</code></a>.</p><p>For algorithms, see <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/orthonormal.jl#L370-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.orthonormalize" href="#KrylovKit.orthonormalize"><code>KrylovKit.orthonormalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orthonormalize(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, β, x
orthonormalize!(v, b::OrthonormalBasis, [x::AbstractVector,] algorithm::Orthogonalizer]) -&gt; w, β, x

orthonormalize(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s
orthonormalize!(v, q, algorithm::Orthogonalizer]) -&gt; w, β, s</code></pre><p>Orthonormalize vector <code>v</code> against all the vectors in the orthonormal basis <code>b</code> using the orthogonalization algorithm <code>algorithm</code>, and return the resulting vector <code>w</code> (of norm 1), its norm <code>β</code> after orthogonalizing and the overlap coefficients <code>x</code> of <code>v</code> with the basis vectors in <code>b</code>, such that <code>v = β * w + b * x</code>.</p><p>In case of <code>orthogonalize!</code>, the vector <code>v</code> is mutated in place. In both functions, storage for the overlap coefficients <code>x</code> can be provided as optional argument <code>x::AbstractVector</code> with <code>length(x) &gt;= length(b)</code>.</p><p>One can also orthonormalize <code>v</code> against a given vector <code>q</code> (assumed to be normalized), in which case the orthonormal vector <code>w</code>, its norm <code>β</code> before normalizing and the inner product <code>s</code> between <code>v</code> and <code>q</code> are returned.</p><p>See <a href="#KrylovKit.orthogonalize"><code>orthogonalize</code></a> if <code>w</code> does not need to be normalized.</p><p>For algorithms, see <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt"><code>ClassicalGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt"><code>ModifiedGramSchmidt</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidt2"><code>ClassicalGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ModifiedGramSchmidt2"><code>ModifiedGramSchmidt2</code></a>, <a href="../algorithms/#KrylovKit.ClassicalGramSchmidtIR"><code>ClassicalGramSchmidtIR</code></a> and <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/orthonormal.jl#L405-L429">source</a></section><h2><a class="nav-anchor" id="Dense-linear-algebra-1" href="#Dense-linear-algebra-1">Dense linear algebra</a></h2><p>KrylovKit relies on Julia&#39;s <code>LinearAlgebra</code> module from the standard library for most of its dense linear algebra dependencies.</p><h2><a class="nav-anchor" id="Krylov-factorizations-1" href="#Krylov-factorizations-1">Krylov factorizations</a></h2><p>The central ingredient in a Krylov based algorithm is a Krylov factorization or decomposition of a linear map. Such partial factorizations are represented as a <code>KrylovFactorization</code>, of which <code>LanczosFactorization</code> and <code>ArnoldiFactorization</code> are two concrete implementations:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.KrylovFactorization" href="#KrylovKit.KrylovFactorization"><code>KrylovKit.KrylovFactorization</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type KrylovFactorization{T,S&lt;:Number}
mutable struct LanczosFactorization{T,S&lt;:Real}    &lt;: KrylovFactorization{T,S}
mutable struct ArnoldiFactorization{T,S&lt;:Number}  &lt;: KrylovFactorization{T,S}</code></pre><p>Structures to store a Krylov factorization of a linear map <code>A</code> of the form</p><pre><code class="language-julia">    A * V = V * B + r * b&#39;.</code></pre><p>For a given Krylov factorization <code>fact</code> of length <code>k = length(fact)</code>, the basis <code>A is obtained via [</code>basis(fact)<code>](@ref basis) and is an instance of some subtype of [</code>Basis{T}<code>](@ref Basis), with also</code>length(V) == k<code>and where</code>T<code>denotes the type of vector like objects used in the problem. The Rayleigh quotient</code>B<code>is obtained as [</code>rayleighquotient(fact)<code>](@ref) and</code>typeof(B)<code>is some subtype of</code>AbstractMatrix{S}<code>with</code>size(B) == (k,k)<code>, typically a structured matrix. The residual</code>r<code>is obtained as [</code>residual(fact)<code>](@ref) and is of type</code>T<code>. One can also query [</code>normres(fact)<code>](@ref) to obtain</code>norm(r)<code>, the norm of the residual. The vector</code>b<code>has no dedicated name and often takes a default form (see below). It should be a subtype of</code>AbstractVector<code>of length</code>k<code>and can be obtained as [</code>rayleighextension(fact)`](@ref) (by lack of a better dedicated name).</p><p>In particular, <code>LanczosFactorization</code> stores a Lanczos factorization of a real symmetric or complex hermitian linear map and has <code>V::OrthonormalBasis{T}</code> and <code>B::SymTridiagonal{S&lt;:Real}</code>. <code>ArnoldiFactorization</code> stores an Arnoldi factorization of a general linear map and has <code>V::OrthonormalBasis{T}</code> and <a href="man/@ref PackedHessenberg"><code>B::PackedHessenberg{S&lt;:Number}</code></a>. In both cases, <code>b</code> takes the default value <span>$e_k$</span>, i.e. the unit vector of all zeros and a one in the last entry, which is represented using <a href="man/@ref"><code>SimpleBasisVector</code></a>.</p><p>A Krylov factorization <code>fact</code> can be destructured as <code>V, B, r, nr, b = fact</code> with <code>nr = norm(r)</code>.</p><p><code>LanczosFactorization</code> and <code>ArnoldiFactorization</code> are mutable because they can <a href="#KrylovKit.expand!"><code>expand!</code></a> or <a href="#KrylovKit.shrink!"><code>shrink!</code></a>. See also <a href="#KrylovKit.KrylovIterator"><code>KrylovIterator</code></a> (and in particular <a href="man/@ref"><code>LanczosIterator</code></a> and <a href="man/@ref"><code>ArnoldiIterator</code></a>) for iterators that construct progressively expanding Krylov factorizations of a given linear map and a starting vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L168-L204">source</a></section><p>A <code>KrylovFactorization</code> can be destructered into its defining components using iteration, but these can also be accessed using the following functions</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.basis" href="#KrylovKit.basis"><code>KrylovKit.basis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    basis(fact::KrylovFactorization)</code></pre><p>Return the list of basis vectors of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which span the Krylov subspace. The return type is a subtype of <code>Basis{T}</code>, where <code>T</code> represents the type of the vectors used by the problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L84-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.rayleighquotient" href="#KrylovKit.rayleighquotient"><code>KrylovKit.rayleighquotient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rayleighquotient(fact::KrylovFactorization)</code></pre><p>Return the Rayleigh quotient of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, i.e. the reduced matrix within the basis of the Krylov subspace. The return type is a subtype of <code>AbstractMatrix{&lt;:Number}</code>, typically some structured matrix type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L93-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.residual" href="#KrylovKit.residual"><code>KrylovKit.residual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">residual(fact::KrylovFactorization)</code></pre><p>Return the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. The return type is some vector of the same type as used in the problem. See also <a href="#KrylovKit.normres"><code>normres(F)</code></a> for its norm, which typically has been computed already.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L102-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.normres" href="#KrylovKit.normres"><code>KrylovKit.normres</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normres(fact::KrylovFactorization)</code></pre><p>Return the norm of the residual of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>. As this has typically already been computed, it is cheaper than (but otherwise equivalent to) <code>norm(residual(F))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L111-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.rayleighextension" href="#KrylovKit.rayleighextension"><code>KrylovKit.rayleighextension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rayleighextension(fact::KrylovFactorization)</code></pre><p>Return the vector <code>b</code> appearing in the definition of a <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L119-L123">source</a></section><h2><a class="nav-anchor" id="Krylov-iterators-1" href="#Krylov-iterators-1">Krylov iterators</a></h2><p>Given a linear map <span>$A$</span> and a starting vector <span>$x₀$</span>, a Krylov factorization is obtained by sequentially building a Krylov subspace <span>${x₀, A x₀, A² x₀, ...}$</span>. Rather then using this set of vectors as a basis, an orthonormal basis is generated by a process known as Lanczos or Arnoldi iteration (for symmetric/hermitian and for general matrices, respectively). These processes are represented as iterators in Julia:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.KrylovIterator" href="#KrylovKit.KrylovIterator"><code>KrylovKit.KrylovIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type KrylovIterator{F,T}
struct LanczosIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}
struct ArnoldiIterator{F,T,O&lt;:Orthogonalizer} &lt;: KrylovIterator{F,T}

LanczosIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth], keepvecs::Bool = true)
ArnoldiIterator(f, v₀, [orth::Orthogonalizer = KrylovDefaults.orth])</code></pre><p>Iterators that take a linear map of type <code>F</code> and an initial vector of type <code>T</code> and generate an expanding <code>KrylovFactorization</code> thereof.</p><p>In particular, for a real symmetric or complex hermitian linear map <code>f</code>, <code>LanczosIterator</code> uses the <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm">Lanczos iteration</a> scheme to build a successively expanding <code>LanczosFactorization</code>. While <code>f</code> cannot be tested to be symmetric or hermitian directly when the linear map is encoded as a general callable object or function, it is tested whether the imaginary part of <code>dot(v, f(v))</code> is sufficiently small to be neglected.</p><p>Similarly, for a general linear map <code>f</code>, <code>ArnoldiIterator</code> iterates over progressively expanding <code>ArnoldiFactorizations</code> using the <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi iteration</a>.</p><p>The optional argument <code>orth</code> specifies which <a href="man/@ref"><code>Orthogonalizer</code></a> to be used. The default value in <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> is to use <a href="../algorithms/#KrylovKit.ModifiedGramSchmidtIR"><code>ModifiedGramSchmidtIR</code></a>, which possibly uses reorthogonalization steps. For <code>LanczosIterator</code>, one can use to discard the old vectors that span the Krylov subspace by setting the final argument <code>keepvecs</code> to <code>false</code>. This, however, is only possible if an <code>orth</code> algorithm is used that does not rely on reorthogonalization, such as <code>ClassicalGramSchmidt()</code> or <code>ModifiedGramSchmidt()</code>. In that case, the iterator strictly uses the Lanczos three-term recurrence relation.</p><p>When iterating over an instance of <code>KrylovIterator</code>, the values being generated are subtypes of <a href="#KrylovKit.KrylovFactorization"><code>KrylovFactorization</code></a>, which can be immediately destructured into a <a href="#KrylovKit.basis"><code>basis</code></a>, <a href="#KrylovKit.rayleighquotient"><code>rayleighquotient</code></a>, <a href="#KrylovKit.residual"><code>residual</code></a>, <a href="#KrylovKit.normres"><code>normres</code></a> and <a href="#KrylovKit.rayleighextension"><code>rayleighextension</code></a>, for example as</p><pre><code class="language-julia">for V,B,r,nr,b in ArnoldiIterator(f, v₀)
    # do something
    nr &lt; tol &amp;&amp; break # a typical stopping criterion
end</code></pre><p>Note, however, that if <code>keepvecs=false</code> in <code>LanczosIterator</code>, the basis <code>V</code> cannot be extracted. Since the iterators don&#39;t know the dimension of the underlying vector space of objects of type <code>T</code>, they keep expanding the Krylov subspace until <code>normres</code> falls below machine precision <code>eps</code> for the given <code>eltype(T)</code>.</p><p>The internal state of <code>LanczosIterator</code> and <code>ArnoldiIterator</code> is the same as the return value, i.e. the corresponding <code>LanczosFactorization</code> or <code>ArnoldiFactorization</code>. However, as Julia&#39;s Base iteration interface (using <code>Base.iterate</code>) requires that the state is not mutated, a <code>deepcopy</code> is produced upon every next iteration step.</p><p>Instead, you can also mutate the <code>KrylovFactorization</code> in place, using the following interface, e.g. for the same example above</p><pre><code class="language-julia">iterator = ArnoldiIterator(f, v₀)
factorization = initialize(iterator)
while normres(factorization) &gt; tol
    expand!(iterator, f)
    V,B,r,nr,b = factorization
    # do something
end</code></pre><p>Here, <a href="#KrylovKit.initialize"><code>initialize(::KrylovIterator)</code></a> produces the first Krylov factorization of length 1, and <code>expand!(::KrylovIterator,::KrylovFactorization)</code>(@ref) expands the factorization in place. See also <a href="#KrylovKit.initialize!"><code>initialize!(::KrylovIterator,::KrylovFactorization)</code></a> to initialize in an already existing factorization (most information will be discarded) and <a href="#KrylovKit.shrink!"><code>shrink!(::KrylovFactorization, k)</code></a> to shrink an existing factorization down to length <code>k</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L207-L275">source</a></section><p>The following functions allow to manipulate a <code>KrylovFactorization</code> obtained from such a <code>KrylovIterator</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.expand!" href="#KrylovKit.expand!"><code>KrylovKit.expand!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">expand!(iter::KrylovIteraotr, fact::KrylovFactorization)</code></pre><p>Expand the Krylov factorization <code>fact</code> by one using the linear map and parameters in <code>iter</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L134-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.shrink!" href="#KrylovKit.shrink!"><code>KrylovKit.shrink!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shrink!(fact::KrylovFactorization, k)</code></pre><p>Shrink an existing Krylov factorization <code>fact</code> down to have length <code>k</code>. Does nothing if <code>length(fact)&lt;=k</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L126-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.initialize!" href="#KrylovKit.initialize!"><code>KrylovKit.initialize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize!(iter::KrylovIteraotr, fact::KrylovFactorization)</code></pre><p>Initialize a length 1 Kryov factorization corresponding to <code>iter</code> in the already existing factorization <code>fact</code>, thereby destroying all the information it currently holds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L141-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.initialize" href="#KrylovKit.initialize"><code>KrylovKit.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">initialize(iter::KrylovIteraotr)</code></pre><p>Initialize a length 1 Kryov factorization corresponding to <code>iter</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/3283e4b33409aff8b9199bc7f70dc75ccd172e3b/src/KrylovKit.jl#L149-L153">source</a></section><footer><hr/><a class="previous" href="../algorithms/"><span class="direction">Previous</span><span class="title">Available algorithms</span></a></footer></article></body></html>
