<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear problems · KrylovKit.jl</title><meta name="title" content="Linear problems · KrylovKit.jl"/><meta property="og:title" content="Linear problems · KrylovKit.jl"/><meta property="twitter:title" content="Linear problems · KrylovKit.jl"/><meta name="description" content="Documentation for KrylovKit.jl."/><meta property="og:description" content="Documentation for KrylovKit.jl."/><meta property="twitter:description" content="Documentation for KrylovKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">KrylovKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Linear problems</a><ul class="internal"><li><a class="tocitem" href="#Linear-systems"><span>Linear systems</span></a></li><li><a class="tocitem" href="#Automatic-differentation"><span>Automatic differentation</span></a></li></ul></li><li><a class="tocitem" href="../leastsquares/">Least squares problems</a></li><li><a class="tocitem" href="../eig/">Eigenvalue problems</a></li><li><a class="tocitem" href="../svd/">Singular value problems</a></li><li><a class="tocitem" href="../matfun/">Functions of matrices and linear operators</a></li><li><a class="tocitem" href="../reallinear/">Real linear maps</a></li><li><a class="tocitem" href="../algorithms/">Available algorithms</a></li><li><a class="tocitem" href="../implementation/">Implementation details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Linear problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/linear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-problems"><a class="docs-heading-anchor" href="#Linear-problems">Linear problems</a><a id="Linear-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-problems" title="Permalink"></a></h1><h2 id="Linear-systems"><a class="docs-heading-anchor" href="#Linear-systems">Linear systems</a><a id="Linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-systems" title="Permalink"></a></h2><p>Linear systems are of the form <code>A*x=b</code> where <code>A</code> should be a linear map that has the same type of output as input, i.e. the solution <code>x</code> should be of the same type as the right hand side <code>b</code>. They can be solved using the function <code>linsolve</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.linsolve" href="#KrylovKit.linsolve"><code>KrylovKit.linsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linsolve(A::AbstractMatrix, b::AbstractVector, [x₀, a₀::Number = 0, a₁::Number = 1]; kwargs...)
linsolve(f, b, [x₀, a₀::Number = 0, a₁::Number = 1]; kwargs...)
# expert version:
linsolve(f, b, x₀, algorithm, [a₀::Number = 0, a₁::Number = 1]; alg_rrule=algorithm)</code></pre><p>Compute a solution <code>x</code> to the linear system <code>(a₀ + a₁ * A)*x = b</code> or <code>a₀ * x + a₁ * f(x) = b</code>, possibly using a starting guess <code>x₀</code>. Return the approximate solution <code>x</code> and a <code>ConvergenceInfo</code> structure.</p><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object. If no initial guess is specified, it is chosen as <code>(zero(a₀)*zero(a₁))*b</code> which should generate an object similar to <code>b</code> but initialized with zeros. The numbers <code>a₀</code> and <code>a₁</code> are optional arguments; they are applied implicitly, i.e. they do not contribute the computation time of applying the linear map or to the number of operations on vectors of type <code>x</code> and <code>b</code>.</p><p><strong>Return values:</strong></p><p>The return value is always of the form <code>x, info = linsolve(...)</code> with</p><ul><li><p><code>x</code>: the approximate solution to the problem, similar type as the right hand side <code>b</code> but possibly with a different <code>scalartype</code></p></li><li><p><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields</p><ul><li><code>info.converged::Int</code>: takes value 0 or 1 depending on whether the solution was converged up to the requested tolerance</li><li><code>info.residual</code>: residual <code>b - f(x)</code> of the approximate solution <code>x</code></li><li><code>info.normres::Real</code>: norm of the residual, i.e. <code>norm(info.residual)</code></li><li><code>info.numops::Int</code>: total number of times that the linear map was applied, i.e. the number of times that <code>f</code> was called, or a vector was multiplied with <code>A</code></li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Check for convergence</header><div class="admonition-body"><p>No warning is printed if no converged solution was found, so always check if <code>info.converged == 1</code>.</p></div></div><p><strong>Keyword arguments:</strong></p><p>Keyword arguments are given by:</p><ul><li><code>verbosity::Int = 0</code>: verbosity level, i.e. <ul><li>0 (suppress all messages)</li><li>1 (only warnings)</li><li>2 (information at the beginning and end)</li><li>3 (progress info after every iteration)</li></ul></li><li><code>atol::Real</code>: the requested accuracy, i.e. absolute tolerance, on the norm of the residual.</li><li><code>rtol::Real</code>: the requested accuracy on the norm of the residual, relative to the norm of the right hand side <code>b</code>.</li><li><code>tol::Real</code>: the requested accuracy on the norm of the residual that is actually used by the algorithm; it defaults to <code>max(atol, rtol*norm(b))</code>. So either use <code>atol</code> and <code>rtol</code> or directly use <code>tol</code> (in which case the value of <code>atol</code> and <code>rtol</code> will be ignored).</li><li><code>krylovdim::Integer</code>: the maximum dimension of the Krylov subspace that will be constructed.</li><li><code>maxiter::Integer</code>: the number of times the Krylov subspace can be rebuilt; see below for further details on the algorithms.</li><li><code>orth::Orthogonalizer</code>: the orthogonalization method to be used, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a></li><li><code>issymmetric::Bool</code>: if the linear map is symmetric, only meaningful if <code>T&lt;:Real</code></li><li><code>ishermitian::Bool</code>: if the linear map is hermitian</li><li><code>isposdef::Bool</code>: if the linear map is positive definite</li></ul><p>The default values are given by <code>atol = KrylovDefaults.tol[]</code>, <code>rtol = KrylovDefaults.tol[]</code>, <code>tol = max(atol, rtol*norm(b))</code>, <code>krylovdim = KrylovDefaults.krylovdim[]</code>, <code>maxiter = KrylovDefaults.maxiter[]</code>, <code>orth = KrylovDefaults.orth</code>; see <a href="../algorithms/#KrylovKit.KrylovDefaults"><code>KrylovDefaults</code></a> for details.</p><p>The default value for the last three parameters depends on the method. If an <code>AbstractMatrix</code> is used, <code>issymmetric</code>, <code>ishermitian</code> and <code>isposdef</code> are checked for that matrix, ortherwise the default values are <code>issymmetric = false</code>, <code>ishermitian = T &lt;: Real &amp;&amp; issymmetric</code> and <code>isposdef = false</code>.</p><p>The final keyword argument <code>alg_rrule</code> is relevant only when <code>linsolve</code> is used in a setting where reverse-mode automatic differentation will be used. A custom <code>ChainRulesCore.rrule</code> is defined for <code>linsolve</code>, which can be evaluated using different algorithms that can be specified via <code>alg_rrule</code>. As the pullback of <code>linsolve</code> involves solving a linear system with the (Hermitian) adjoint of the linear map, the default value is to use the same algorithm. This keyword argument should only be used when this default choice is failing or not performing efficiently. Check the documentation for more information on the possible values for <code>alg_rrule</code> and their implications on the algorithm being used.</p><p><strong>Algorithms</strong></p><p>The final (expert) method, without default values and keyword arguments, is the one that is finally called, and can also be used directly. Here, one specifies the algorithm explicitly. Currently, only <a href="../algorithms/#KrylovKit.CG"><code>CG</code></a>, <a href="../algorithms/#KrylovKit.GMRES"><code>GMRES</code></a>, <a href="../algorithms/#KrylovKit.BiCGStab"><code>BiCGStab</code></a> and <a href="../algorithms/#KrylovKit.LSMR"><code>LSMR</code></a> are implemented, where <code>CG</code> is chosen if <code>isposdef == true</code> and <code>GMRES</code> is chosen otherwise. Note that in standard <code>GMRES</code> terminology, our parameter <code>krylovdim</code> is referred to as the <em>restart</em> parameter, and our <code>maxiter</code> parameter counts the number of outer iterations, i.e. restart cycles. In <code>CG</code>, the Krylov subspace is only implicit because short recurrence relations are being used, and therefore no restarts are required. Therefore, we pass <code>krylovdim*maxiter</code> as the maximal number of CG iterations that can be used by the <code>CG</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/68ced469e833613e00c70871f82846b525a9d7c8/src/linsolve/linsolve.jl#L1-L98">source</a></section></article><h2 id="Automatic-differentation"><a class="docs-heading-anchor" href="#Automatic-differentation">Automatic differentation</a><a id="Automatic-differentation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentation" title="Permalink"></a></h2><p>The <code>linsolve</code> routine can be used in conjunction with reverse-mode automatic differentiation, using AD engines that are compatible with the <a href="https://juliadiff.org/ChainRulesCore.jl/dev/">ChainRules</a> ecosystem. The adjoint problem of a linear problem is again a linear problem, that requires the adjoint<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> of the linear map. If the linear map is an <code>AbstractMatrix</code> instance, its <code>adjoint</code> will be used in the <code>rrule</code>. If the linear map is implemented as a function <code>f</code>, then the AD engine itself is used to compute the corresponding adjoint via <code>ChainRulesCore.rrule_via_ad(config, f, x)</code>. The specific base point <code>x</code> at which this adjoint is computed should not affect the result if <code>f</code> properly represents a linear map. Furthermore, the <code>linsolve</code> output is only affected by the linear map argument and the right hand side argument <code>b</code> (from a theoretical perspective, the starting vector and algorithm parameters should have no effect), so that these two arguments are where the adjoint  variables need to be propagated to and have a nonzero effect.</p><p>The adjoint linear problem (also referred to as cotangent problem) is by default solved using the same algorithms as the primal problem. However, the <code>rrule</code> can be customized to use a different Krylov algorithm, by specifying the <code>alg_rrule</code> keyword argument. Its value can take any of the values as the <code>algorithm</code> argument in <code>linsolve</code>.</p><p>with its (conjugate) transpose, at least with respect to the standard Euclidean inner product.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For a linear map, the adjoint or pullback required in the reverse-order chain rule coincides</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../leastsquares/">Least squares problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 23 March 2025 21:20">Sunday 23 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
