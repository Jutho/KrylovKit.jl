<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Singular value problems · KrylovKit.jl</title><meta name="title" content="Singular value problems · KrylovKit.jl"/><meta property="og:title" content="Singular value problems · KrylovKit.jl"/><meta property="twitter:title" content="Singular value problems · KrylovKit.jl"/><meta name="description" content="Documentation for KrylovKit.jl."/><meta property="og:description" content="Documentation for KrylovKit.jl."/><meta property="twitter:description" content="Documentation for KrylovKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">KrylovKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../linear/">Linear problems</a></li><li><a class="tocitem" href="../leastsquares/">Least squares problems</a></li><li><a class="tocitem" href="../eig/">Eigenvalue problems</a></li><li class="is-active"><a class="tocitem" href>Singular value problems</a><ul class="internal"><li><a class="tocitem" href="#Singular-values-and-singular-vectors"><span>Singular values and singular vectors</span></a></li><li><a class="tocitem" href="#Automatic-differentation"><span>Automatic differentation</span></a></li></ul></li><li><a class="tocitem" href="../matfun/">Functions of matrices and linear operators</a></li><li><a class="tocitem" href="../reallinear/">Real linear maps</a></li><li><a class="tocitem" href="../algorithms/">Available algorithms</a></li><li><a class="tocitem" href="../implementation/">Implementation details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Singular value problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Singular value problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/svd.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Singular-value-problems"><a class="docs-heading-anchor" href="#Singular-value-problems">Singular value problems</a><a id="Singular-value-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-value-problems" title="Permalink"></a></h1><h2 id="Singular-values-and-singular-vectors"><a class="docs-heading-anchor" href="#Singular-values-and-singular-vectors">Singular values and singular vectors</a><a id="Singular-values-and-singular-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-values-and-singular-vectors" title="Permalink"></a></h2><p>It is possible to iteratively compute a few singular values and corresponding left and right singular vectors using the function <code>svdsolve</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.svdsolve" href="#KrylovKit.svdsolve"><code>KrylovKit.svdsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svdsolve(A::AbstractMatrix, [x₀, howmany = 1, which = :LR, T = eltype(A)]; kwargs...)
svdsolve(f, m::Int, [howmany = 1, which = :LR, T = Float64]; kwargs...)
svdsolve(f, x₀, [howmany = 1, which = :LR]; kwargs...)
# expert version:
svdsolve(f, x₀, howmany, which, algorithm; alg_rrule=...)</code></pre><p>Compute <code>howmany</code> singular values from the linear map encoded in the matrix <code>A</code> or by the function <code>f</code>. Return singular values, left and right singular vectors and a <code>ConvergenceInfo</code> structure.</p><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object. Since both the action of the linear map and its adjoint are required in order to compute singular values, <code>f</code> can either be a tuple of two callable objects (each accepting a single argument), representing the linear map and its adjoint respectively, or, <code>f</code> can be a single callable object that accepts two input arguments, where the second argument is a flag of type <code>Val{true}</code> or <code>Val{false}</code> that indicates whether the adjoint or the normal action of the linear map needs to be computed. The latter form still combines well with the <code>do</code> block syntax of Julia, as in</p><pre><code class="language-julia hljs">vals, lvecs, rvecs, info = svdsolve(x₀, howmany, which; kwargs...) do x, flag
    if flag === Val(true)
        # y = compute action of adjoint map on x
    else
        # y = compute action of linear map on x
    end
    return y
end</code></pre><p>For a general linear map encoded using either the tuple or the two-argument form, the best approach is to provide a start vector <code>x₀</code> (in the codomain, i.e. column space, of the linear map). Alternatively, one can specify the number <code>m</code> of rows of the linear map, in which case <code>x₀ = rand(T, m)</code> is used, where the default value of <code>T</code> is <code>Float64</code>, unless specified differently. If an <code>AbstractMatrix</code> is used, a starting vector <code>x₀</code> does not need to be provided; it is chosen as <code>rand(T, size(A, 1))</code>.</p><p>The next arguments are optional, but should typically be specified. <code>howmany</code> specifies how many singular values and vectors should be computed; <code>which</code> specifies which singular values should be targeted. Valid specifications of <code>which</code> are</p><ul><li><code>LR</code>: largest singular values</li><li><code>SR</code>: smallest singular values However, the largest singular values tend to converge more rapidly.</li></ul><p><strong>Return values:</strong></p><p>The return value is always of the form <code>vals, lvecs, rvecs, info = svdsolve(...)</code> with</p><ul><li><code>vals</code>: a <code>Vector{&lt;:Real}</code> containing the singular values, of length at least <code>howmany</code>, but could be longer if more singular values were converged at the same cost.</li><li><code>lvecs</code>: a <code>Vector</code> of corresponding left singular vectors, of the same length as <code>vals</code>.</li><li><code>rvecs</code>: a <code>Vector</code> of corresponding right singular vectors, of the same length as <code>vals</code>. Note that singular vectors are not returned as a matrix, as the linear map could act on any custom Julia type with vector like behavior, i.e. the elements of the</li></ul><p>lists <code>lvecs</code>(<code>rvecs</code>) are objects that are typically similar to the starting guess <code>x₀</code>(<code>A&#39; * x₀</code>), up to a possibly different <code>eltype</code>. When the linear map is a simple     <code>AbstractMatrix</code>, <code>lvecs</code> and <code>rvecs</code> will be <code>Vector{Vector{&lt;:Number}}</code>.</p><ul><li><p><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields</p><ul><li><code>info.converged::Int</code>: indicates how many singular values and vectors were actually converged to the specified tolerance <code>tol</code> (see below under keyword arguments)</li><li><code>info.residual::Vector</code>: a list of the same length as <code>vals</code> containing the residuals <code>info.residual[i] = A * rvecs[i] - vals[i] * lvecs[i]</code>.</li><li><code>info.normres::Vector{&lt;:Real}</code>: list of the same length as <code>vals</code> containing the norm of the residual <code>info.normres[i] = norm(info.residual[i])</code></li><li><code>info.numops::Int</code>: number of times the linear map was applied, i.e. number of times <code>f</code> was called, or a vector was multiplied with <code>A</code> or <code>A&#39;</code>.</li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Check for convergence</header><div class="admonition-body"><p>No warning is printed if not all requested singular values were converged, so always check if <code>info.converged &gt;= howmany</code>.</p></div></div><p><strong>Keyword arguments:</strong></p><p>Keyword arguments and their default values are given by:</p><ul><li><code>verbosity::Int = 0</code>: verbosity level<ul><li>0 (suppress all messages)</li><li>1 (only warnings)</li><li>2 (one message with convergence info at the end)</li><li>3 (progress info after every iteration)</li><li>4+ (all of the above and additional information about the GKL iteration)</li></ul></li><li><code>krylovdim</code>: the maximum dimension of the Krylov subspace that will be constructed. Note that the dimension of the vector space is not known or checked, e.g. <code>x₀</code> should not necessarily support the <code>Base.length</code> function. If you know the actual problem dimension is smaller than the default value, it is useful to reduce the value of <code>krylovdim</code>, though in principle this should be detected.</li><li><code>tol</code>: the requested accuracy according to <code>normres</code> as defined above. If you work in e.g. single precision (<code>Float32</code>), you should definitely change the default value.</li><li><code>maxiter</code>: the number of times the Krylov subspace can be rebuilt; see below for further details on the algorithms.</li><li><code>orth</code>: the orthogonalization method to be used, see <a href="../algorithms/#KrylovKit.Orthogonalizer"><code>Orthogonalizer</code></a></li><li><code>eager::Bool = false</code>: if true, eagerly compute the SVD after every expansion of the Krylov subspace to test for convergence, otherwise wait until the Krylov subspace has dimension <code>krylovdim</code></li></ul><p>The final keyword argument <code>alg_rrule</code> is relevant only when <code>svdsolve</code> is used in a setting where reverse-mode automatic differentation will be used. A custom <code>ChainRulesCore.rrule</code> is defined for <code>svdsolve</code>, which can be evaluated using different algorithms that can be specified via <code>alg_rrule</code>. A suitable default is chosen, so this keyword argument should only be used when this default choice is failing or not performing efficiently. Check the documentation for more information on the possible values for <code>alg_rrule</code> and their implications on the algorithm being used.</p><p><strong>Algorithm</strong></p><p>The last method, without default values and keyword arguments, is the one that is finally called, and can also be used directly. Here the algorithm is specified, though currently only <a href="../algorithms/#KrylovKit.GKL"><code>GKL</code></a> is available. <code>GKL</code> refers to the the partial Golub-Kahan-Lanczos bidiagonalization which forms the basis for computing the approximation to the singular values. This factorization is dynamically shrunk and expanded (i.e. thick restart) similar to the Krylov-Schur factorization for eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/8e1ed1d34c2ac4c0fbd9e5bcef3aa13c3579a720/src/eigsolve/svdsolve.jl#L1-L120">source</a></section></article><h2 id="Automatic-differentation"><a class="docs-heading-anchor" href="#Automatic-differentation">Automatic differentation</a><a id="Automatic-differentation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentation" title="Permalink"></a></h2><p>The <code>svdsolve</code> routine can be used in conjunction with reverse-mode automatic differentiation,  using AD engines that are compatible with the <a href="https://juliadiff.org/ChainRulesCore.jl/dev/">ChainRules</a> ecosystem. The adjoint problem of a singular value problem contains a linear problem, although it can also be formulated as an eigenvalue problem. Details about this approach will be published in a forthcoming manuscript.</p><p>Both <code>svdsolve</code> and the adjoint problem associated with it require the action of the linear map as well as of its adjoint<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Hence, no new information about the linear map is required for the adjoint problem. However, the linear map is the only argument that affects the <code>svdsolve</code> output (from a theoretical perspective, the starting vector and algorithm parameters should have no effect), so that this is where the adjoint variables need to be propagated to.</p><p>The adjoint problem (also referred to as cotangent problem) can thus be solved as a linear problem or as an eigenvalue problem. Note that this eigenvalue problem is never symmetric or Hermitian. The different implementations of the <code>rrule</code> can be selected using the <code>alg_rrule</code> keyword argument.  If a linear solver such as <code>GMRES</code> or <code>BiCGStab</code> is specified, the adjoint problem requires solving a] number of linear problems equal to the number of requested singular values and vectors. If an  eigenvalue solver is specified, for which <code>Arnoldi</code> is essentially the only option, then the adjoint problem is solved as a single (but larger) eigenvalue problem.</p><p>Note that the common pair of left and right singular vectors has an arbitrary phase freedom. Hence, a well-defined cost function constructed from singular should depend on these in such a way  that its value is not affected by simultaneously changing the left and right singular vector with a common phase factor, i.e. the cost function should be &#39;gauge invariant&#39;. If this is not the case,  the cost function is said to be &#39;gauge dependent&#39;, and this can be detected in the resulting adjoint variables for those singular vectors. The KrylovKit <code>rrule</code> for <code>svdsolve</code> will print a warning if it detects from the incoming adjoint variables that the cost function is gauge dependent. This warning can be suppressed by passing <code>alg_rrule</code> an algorithm with <code>verbosity=-1</code>.</p><p>with its (conjugate) transpose, at least with respect to the standard Euclidean inner product.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>For a linear map, the adjoint or pullback required in the reverse-order chain rule coincides</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../eig/">« Eigenvalue problems</a><a class="docs-footer-nextpage" href="../matfun/">Functions of matrices and linear operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 20 February 2025 21:18">Thursday 20 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
