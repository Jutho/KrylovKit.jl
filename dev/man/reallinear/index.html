<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real linear maps · KrylovKit.jl</title><meta name="title" content="Real linear maps · KrylovKit.jl"/><meta property="og:title" content="Real linear maps · KrylovKit.jl"/><meta property="twitter:title" content="Real linear maps · KrylovKit.jl"/><meta name="description" content="Documentation for KrylovKit.jl."/><meta property="og:description" content="Documentation for KrylovKit.jl."/><meta property="twitter:description" content="Documentation for KrylovKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">KrylovKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../linear/">Linear problems</a></li><li><a class="tocitem" href="../leastsquares/">Least squares problems</a></li><li><a class="tocitem" href="../eig/">Eigenvalue problems</a></li><li><a class="tocitem" href="../svd/">Singular value problems</a></li><li><a class="tocitem" href="../matfun/">Functions of matrices and linear operators</a></li><li class="is-active"><a class="tocitem" href>Real linear maps</a></li><li><a class="tocitem" href="../algorithms/">Available algorithms</a></li><li><a class="tocitem" href="../implementation/">Implementation details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Real linear maps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Real linear maps</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/reallinear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Real-linear-maps"><a class="docs-heading-anchor" href="#Real-linear-maps">Real linear maps</a><a id="Real-linear-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Real-linear-maps" title="Permalink"></a></h1><p>A map <span>$f: V \to V$</span> from some vector space <span>$V$</span> to itself is said to be a real linear map if it satisfies <span>$f(\alpha x + \beta y) = \alpha f(x) + \beta f(y)$</span> for all <span>$x, y \in V$</span> and all <span>$\alpha, \beta \in \mathbb{R}$</span>. When <span>$V$</span> is itself a real vector space, this is just the natural concept of a linear map. However, this definition can be used even if <span>$x$</span> and <span>$y$</span> are naturally represented using complex numbers and arithmetic and also admit complex linear combinations, i.e. if <span>$V$</span> is a complex vector space.</p><p>Such real linear maps arise whenever <code>f(x)</code> involves calling <code>conj(x)</code>, and are for example obtained in the context of Jacobians (pullbacks) of complex valued functions that are not holomorphic.</p><p>To deal with real linear maps, one should reinterpret <span>$V$</span> as a real vector space, by restricting the possible linear combinations to those with real scalar coefficients, and by using the real part of the inner product. When the vectors are explictly represented as some <code>AbstractVector{Complex{T}}</code>, this could be obtained by explicitly splitting them in their real and imaginary parts and stacking those into <code>AbstractVector{T}</code> objects with twice the original length.</p><p>However, KrylovKit.jl admits a different approach, where the original representation of vectors is kept, and the inner product is simply replaced by its real part. KrylovKit.jl offers specific methods for solving linear systems and eigenvalue systems in this way. For linear problems, this is implemented using <code>reallinsolve</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.reallinsolve" href="#KrylovKit.reallinsolve"><code>KrylovKit.reallinsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reallinsolve(f, b, x₀, algorithm, [a₀::Real = 0, a₁::Real = 1]; alg_rrule=algorithm)</code></pre><p>Compute a solution <code>x</code> to the linear system <code>a₀ * x + a₁ * f(x) = b</code>, using a starting guess <code>x₀</code>, where <code>f</code> represents a real linear map. Return the approximate solution <code>x</code> and a <code>ConvergenceInfo</code> structure.</p><div class="admonition is-info"><header class="admonition-header">Note about real linear maps</header><div class="admonition-body"><p>A function <code>f</code> is said to implement a real linear map if it satisfies  <code>f(add(x,y)) = add(f(x), f(y)</code> and <code>f(scale(x, α)) = scale(f(x), α)</code> for vectors <code>x</code> and <code>y</code> and scalars <code>α::Real</code>. Note that this is possible even when the vectors are represented using complex arithmetic. For example, the map <code>f=x-&gt; x + conj(x)</code> represents a real linear map that is not (complex) linear, as it does not satisfy <code>f(scale(x, α)) = scale(f(x), α)</code> for complex scalars <code>α</code>. Note that complex linear maps are always real linear maps and thus can be used in this context, though in that case <code>linsolve</code> and <code>reallinsolve</code> target the same solution. However, they still compute that solution using different arithmetic, and in that case <code>linsolve</code> might be more efficient.</p><p>To interpret the vectors <code>x</code> and <code>y</code> as elements from a real vector space, the standard inner product defined on them will be replaced with <code>real(inner(x,y))</code>. This has no effect if the vectors <code>x</code> and <code>y</code> were represented using real arithmetic to begin with, and allows to seemlessly use complex vectors as well.</p></div></div><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object. The real numbers <code>a₀</code> and <code>a₁</code> are optional arguments; they are applied  implicitly,  i.e. they do not contribute the computation time of applying the linear map or to the  number of operations on vectors of type <code>x</code> and <code>b</code>.</p><p><strong>Return values:</strong></p><p>The return value is always of the form <code>x, info = linsolve(...)</code> with</p><ul><li><p><code>x</code>: the approximate solution to the problem, similar type as the right hand side <code>b</code> but possibly with a different <code>scalartype</code></p></li><li><p><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields</p><ul><li><code>info.converged::Int</code>: takes value 0 or 1 depending on whether the solution was converged up to the requested tolerance</li><li><code>info.residual</code>: residual <code>b - f(x)</code> of the approximate solution <code>x</code></li><li><code>info.normres::Real</code>: norm of the residual, i.e. <code>norm(info.residual)</code></li><li><code>info.numops::Int</code>: total number of times that the linear map was applied, i.e. the number of times that <code>f</code> was called, or a vector was multiplied with <code>A</code></li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Check for convergence</header><div class="admonition-body"><p>No warning is printed if no converged solution was found, so always check if <code>info.converged == 1</code>.</p></div></div><p><strong>Algorithms</strong></p><p>The final (expert) method, without default values and keyword arguments, is the one that is finally called, and can also be used directly. Here, one specifies the algorithm explicitly. Currently, only <a href="../algorithms/#KrylovKit.CG"><code>CG</code></a>, <a href="../algorithms/#KrylovKit.GMRES"><code>GMRES</code></a> and <a href="../algorithms/#KrylovKit.BiCGStab"><code>BiCGStab</code></a> are implemented, where <code>CG</code> is chosen if <code>isposdef == true</code> and <code>GMRES</code> is chosen otherwise. Note that in standard <code>GMRES</code> terminology, our parameter <code>krylovdim</code> is referred to as the <em>restart</em> parameter, and our <code>maxiter</code> parameter counts the number of outer iterations, i.e. restart cycles. In <code>CG</code>, the Krylov subspace is only implicit because short recurrence relations are being used, and therefore no restarts are required. Therefore, we pass <code>krylovdim*maxiter</code> as the maximal number of CG iterations that can be used by the <code>CG</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/dd3de660a1c8fa2704cff8a5a547e86732395f01/src/linsolve/linsolve.jl#L180-L247">source</a></section></article><p>In the case of eigenvalue systems, a similar method <code>realeigsolve</code> is available. In this context, only real eigenvalues are meaningful, as the corresponding eigenvectors should be built from real linear combinations of the vectors that span the (real) Krylov subspace. This approach can also be applied to linear maps on vectors that were naturally real to begin with, if it is guaranteed that the targetted eigenvalues are real. In that case, also the associated eigenvectors will be returned using only real arithmic. This is contrast with <code>eigsolve</code>, which will always turn to complex arithmetic if the linear map is real but not symmetric. An error will be thrown if complex eigenvalues are encountered within the targetted set.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KrylovKit.realeigsolve" href="#KrylovKit.realeigsolve"><code>KrylovKit.realeigsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"># expert version:
realeigsolve(f, x₀, howmany, which, algorithm; alg_rrule=algorithm)</code></pre><p>Compute the first <code>howmany</code> eigenvalues (according to the order specified by <code>which</code>) from the real linear map encoded in the matrix <code>A</code> or by the function <code>f</code>, if it can be guaranteed that these eigenvalues (and thus their associated eigenvectors) are real. An error will be thrown if there are complex eigenvalues within the first <code>howmany</code> eigenvalues.</p><p>Return eigenvalues, eigenvectors and a <code>ConvergenceInfo</code> structure.</p><div class="admonition is-info"><header class="admonition-header">Note about real linear maps</header><div class="admonition-body"><p>A function <code>f</code> is said to implement a real linear map if it satisfies  <code>f(add(x,y)) = add(f(x), f(y)</code> and <code>f(scale(x, α)) = scale(f(x), α)</code> for vectors <code>x</code> and <code>y</code> and scalars <code>α::Real</code>. Note that this is possible even when the vectors are represented using complex arithmetic. For example, the map <code>f=x-&gt; x + conj(x)</code> represents a real linear map that is not (complex) linear, as it does not satisfy <code>f(scale(x, α)) = scale(f(x), α)</code> for complex scalars <code>α</code>. Note that complex linear maps are always real linear maps and thus can be used in this context, if looking specifically for real eigenvalues that they may have.</p><p>To interpret the vectors <code>x</code> and <code>y</code> as elements from a real vector space, the standard inner product defined on them will be replaced with <code>real(inner(x,y))</code>. This has no effect if the vectors <code>x</code> and <code>y</code> were represented using real arithmetic to begin with, and allows to seemlessly use complex vectors as well.</p></div></div><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object. A starting vector <code>x₀</code> needs to be provided. Note that <code>x₀</code> does not need to be of type <code>AbstractVector</code>; any type that behaves as a vector and supports the required interface (see KrylovKit docs) is accepted.</p><p>The argument <code>howmany</code> specifies how many eigenvalues should be computed; <code>which</code> specifies which eigenvalues should be targeted. Valid specifications of <code>which</code> for real problems are given by</p><ul><li><code>:LM</code>: eigenvalues of largest magnitude</li><li><code>:LR</code>: eigenvalues with largest (most positive) real part</li><li><code>:SR</code>: eigenvalues with smallest (most negative) real part</li><li><a href="../eig/#KrylovKit.EigSorter"><code>EigSorter(f; rev = false)</code></a>: eigenvalues <code>λ</code> that appear first (or last if <code>rev == true</code>) when sorted by <code>f(λ)</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note about selecting `which` eigenvalues</header><div class="admonition-body"><p>Krylov methods work well for extremal eigenvalues, i.e. eigenvalues on the periphery of the spectrum of the linear map. All of the valid <code>Symbol</code>s for <code>which</code> have this property, but could also be specified using <code>EigSorter</code>, e.g. <code>:LM</code> is equivalent to <code>Eigsorter(abs; rev = true)</code>. Note that smallest magnitude sorting is obtained using e.g. <code>EigSorter(abs; rev = false)</code>, but since no (shift-and)-invert is used, this will only be successful if you somehow know that eigenvalues close to zero are also close to the periphery of the spectrum.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Degenerate eigenvalues</header><div class="admonition-body"><p>From a theoretical point of view, Krylov methods can at most find a single eigenvector associated with a targetted eigenvalue, even if the latter is degenerate. In the case of a degenerate eigenvalue, the specific eigenvector that is returned is determined by the starting vector <code>x₀</code>. For large problems, this turns out to be less of an issue in practice, as often a second linearly independent eigenvector is generated out of the numerical noise resulting from the orthogonalisation steps in the Lanczos or Arnoldi iteration. Nonetheless, it is important to take this into account and to try not to depend on this potentially fragile behaviour, especially for smaller problems.</p></div></div><p>The <code>algorithm</code> argument currently only supports an instance of <a href="../algorithms/#KrylovKit.Arnoldi"><code>Arnoldi</code></a>, which is where the parameters of the Krylov method (such as Krylov dimension and maximum number of iterations) can be specified. Since <code>realeigsolve</code> is less commonly used as <code>eigsolve</code>, it only supports this expert mode call syntax and no convenient keyword interface is currently available.</p><p>The keyword argument <code>alg_rrule</code> can be used to specify an algorithm to be used for computing the <code>pullback</code> of <code>realeigsolve</code> in the context of reverse-mode automatic differentation.</p><p><strong>Return values:</strong></p><p>The return value is always of the form <code>vals, vecs, info = eigsolve(...)</code> with</p><ul><li><p><code>vals</code>: a <code>Vector</code> containing the eigenvalues, of length at least <code>howmany</code>, but could be longer if more eigenvalues were converged at the same cost. Eigenvalues will be real, an <code>ArgumentError</code> will be thrown if the first <code>howmany</code> eigenvalues ordered according to <code>which</code> of the linear map are not all real.</p></li><li><p><code>vecs</code>: a <code>Vector</code> of corresponding eigenvectors, of the same length as <code>vals</code>. Note that eigenvectors are not returned as a matrix, as the linear map could act on any custom Julia type with vector like behavior, i.e. the elements of the list <code>vecs</code> are objects that are typically similar to the starting guess <code>x₀</code>. For a real problem with real eigenvalues, also the eigenvectors will be real and no complex arithmetic is used anywhere.</p></li><li><p><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields</p><ul><li><code>info.converged::Int</code>: indicates how many eigenvalues and eigenvectors were actually converged to the specified tolerance <code>tol</code> (see below under keyword arguments)</li><li><code>info.residual::Vector</code>: a list of the same length as <code>vals</code> containing the residuals <code>info.residual[i] = f(vecs[i]) - vals[i] * vecs[i]</code></li><li><code>info.normres::Vector{&lt;:Real}</code>: list of the same length as <code>vals</code> containing the norm of the residual <code>info.normres[i] = norm(info.residual[i])</code></li><li><code>info.numops::Int</code>: number of times the linear map was applied, i.e. number of times <code>f</code> was called, or a vector was multiplied with <code>A</code></li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">Check for convergence</header><div class="admonition-body"><p>No warning is printed if not all requested eigenvalues were converged, so always check if <code>info.converged &gt;= howmany</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/dd3de660a1c8fa2704cff8a5a547e86732395f01/src/eigsolve/arnoldi.jl#L187-L291">source</a></section></article><p>Note that both <code>reallinsolve</code> and <code>realeigsolve</code> currently only exist with the &quot;expert&quot; mode interface, where the user has to manually specify the underlying Krylov algorithm and its parameters, i.e. <code>GMRES</code> or <code>BiCGStab</code> for <code>reallinsolve</code> and <code>Arnoldi</code> for <code>realeigsolve</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matfun/">« Functions of matrices and linear operators</a><a class="docs-footer-nextpage" href="../algorithms/">Available algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 17 January 2025 14:13">Friday 17 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
